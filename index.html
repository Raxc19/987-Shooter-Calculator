<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Team 987 High Rollers - Shooter Calculator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Pinyon+Script&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0d0d0d 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .team-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .team-header .team-number {
            font-family: Arial, Helvetica, sans-serif;
            font-size: 1.8em;
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }

        .team-header .team-logo-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 8px;
        }

        .team-header .dice-logo {
            height: 86px;
            width: auto;
        }

        .team-header .team-name {
            font-family: 'Pinyon Script', cursive;
            font-size: 3.45em;
            color: #8B1A1A;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .team-header .calculator-title {
            font-size: 1.1em;
            color: #cc3333;
            font-weight: bold;
            margin-top: 5px;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 20px;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 350px 1fr 300px;
            gap: 20px;
        }

        .panel {
            background: rgba(8, 8, 8, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(89, 0, 0, 0.2);
        }

        .panel.results-panel {
            position: sticky;
            top: 20px;
            align-self: start;
            max-height: calc(100vh - 60px);
            overflow-y: auto;
        }

        .panel h2 {
            color: #cc3333;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 1px solid rgba(89, 0, 0, 0.5);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 0.85em;
        }

        .control-group select,
        .control-group input[type="number"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 0.95em;
        }

        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: #590000;
            box-shadow: 0 0 10px rgba(89, 0, 0, 0.3);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-container input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #590000;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(89, 0, 0, 0.5);
        }

        .slider-value {
            min-width: 60px;
            text-align: right;
            color: #cc3333;
            font-weight: bold;
        }

        .input-slider-combo {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-slider-combo .input-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .input-slider-combo input[type="number"] {
            width: 80px;
            padding: 6px 10px;
            border: 1px solid rgba(89, 0, 0, 0.4);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: #cc3333;
            font-size: 0.95em;
            font-weight: bold;
            text-align: center;
        }

        .input-slider-combo input[type="number"]:focus {
            outline: none;
            border-color: #590000;
            box-shadow: 0 0 10px rgba(89, 0, 0, 0.3);
        }

        .input-slider-combo .unit {
            color: #888;
            font-size: 0.85em;
            min-width: 30px;
        }

        .input-slider-combo input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
        }

        .input-slider-combo input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #590000;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(89, 0, 0, 0.5);
        }

        /* Hide spinner buttons on number inputs */
        .input-slider-combo input[type="number"]::-webkit-outer-spin-button,
        .input-slider-combo input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .input-slider-combo input[type="number"] {
            -moz-appearance: textfield;
        }

        .canvas-container {
            position: sticky;
            top: 20px;
            background: rgba(8, 8, 8, 0.9);
            border-radius: 15px;
            overflow: hidden;
            min-height: 500px;
            max-height: calc(100vh - 100px);
            align-self: start;
            border: 1px solid rgba(89, 0, 0, 0.2);
        }

        #trajectoryCanvas {
            display: block;
        }

        .results-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .result-item {
            background: rgba(89, 0, 0, 0.1);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(89, 0, 0, 0.15);
        }

        .result-item .label {
            color: #888;
            font-size: 0.75em;
            text-transform: uppercase;
        }

        .result-item .value {
            color: #cc3333;
            font-size: 1.1em;
            font-weight: bold;
        }

        .result-item.full-width {
            grid-column: 1 / -1;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.success { background: #00ff88; box-shadow: 0 0 10px #00ff88; }
        .status-indicator.warning { background: #ffaa00; box-shadow: 0 0 10px #ffaa00; }
        .status-indicator.error { background: #ff4444; box-shadow: 0 0 10px #ff4444; }

        .game-piece-info {
            background: rgba(89, 0, 0, 0.15);
            border: 1px solid rgba(89, 0, 0, 0.4);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 0.85em;
        }

        .game-piece-info h3 {
            color: #cc3333;
            margin-bottom: 5px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #590000;
        }

        .section-divider {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin: 15px 0;
            padding-top: 15px;
        }

        @media (max-width: 1200px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="team-header">
            <div class="team-number">Team 987</div>
            <div class="team-logo-row">
                <img src="dice-logo.png" alt="Dice Logo" class="dice-logo">
                <span class="team-name">The High Rollers</span>
                <img src="dice-logo.png" alt="Dice Logo" class="dice-logo">
            </div>
            <div class="calculator-title">Shooter Calculator</div>
        </div>
        <p class="subtitle">FRC 2026 REBUILT - Real-time trajectory simulation</p>

        <div class="main-layout">
            <!-- Left Panel - Controls -->
            <div class="panel">
                <!-- Configuration Manager -->
                <div style="background: rgba(89, 0, 0, 0.1); border: 1px solid rgba(89, 0, 0, 0.3); border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                    <h3 style="color: #cc3333; margin-bottom: 10px; font-size: 1em;">Configuration Manager</h3>
                    <div class="control-group" style="margin-bottom: 10px;">
                        <label>Config Name</label>
                        <input type="text" id="configName" placeholder="My Shooter Config" style="width: 100%; padding: 6px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: #fff;">
                    </div>
                    <div class="control-group" style="margin-bottom: 10px;">
                        <label>Saved Configs</label>
                        <select id="savedConfigsDropdown" style="width: 100%; padding: 6px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: #fff;">
                            <option value="">-- Select Config --</option>
                        </select>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 8px;">
                        <button id="saveConfigBtn" style="padding: 8px; background: #590000; color: #fff; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 0.85em;">Save Config</button>
                        <button id="loadConfigBtn" style="padding: 8px; background: #590000; color: #fff; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 0.85em;">Load Selected</button>
                        <button id="deleteConfigBtn" style="padding: 8px; background: #590000; color: #fff; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 0.85em;">Delete Selected</button>
                        <button id="exportConfigBtn" style="padding: 8px; background: #590000; color: #fff; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 0.85em;">Export to File</button>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 8px;">
                        <button id="addToGraphBtn" style="padding: 8px; background: #590000; color: #fff; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 0.85em;">Add to Graph</button>
                        <button id="clearGraphBtn" style="padding: 8px; background: #590000; color: #fff; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 0.85em;">Clear All Overlays</button>
                    </div>
                    <input type="file" id="importConfigFile" accept=".json" style="display: none;">
                    <button id="importConfigBtn" style="width: 100%; padding: 8px; background: #590000; color: #fff; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 0.85em;">Import from File</button>
                    <div id="overlaysList" style="margin-top: 10px; font-size: 0.85em;"></div>
                </div>

                <div class="game-piece-info">
                    <h3>FUEL Game Piece</h3>
                    <div>Diameter: 5.91" | Weight: 0.47 lbs</div>
                    <div>High-density foam (~30 Shore A)</div>
                </div>

                <!-- Belt Calculator -->
                <div style="background: rgba(89, 0, 0, 0.15); border: 1px solid rgba(89, 0, 0, 0.4); border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                    <h3 style="color: #cc3333; margin-bottom: 10px; font-size: 1em; cursor: pointer;" onclick="const el = document.getElementById('beltCalcContent'); el.style.display = el.style.display === 'none' ? 'block' : 'none'; if (el.style.display === 'block') calculateBelt();">
                        Belt Calculator [+]
                    </h3>
                    <div id="beltCalcContent" style="display: none;">
                        <div class="control-group" style="margin-bottom: 10px;">
                            <label>Belt Pitch</label>
                            <select id="beltPitch" style="width: 100%; padding: 6px; border-radius: 6px; border: 1px solid rgba(89,0,0,0.3); background: rgba(0,0,0,0.3); color: #fff;">
                                <option value="5">5mm (HTD 5M / GT2-5)</option>
                                <option value="3">3mm (GT2-3)</option>
                            </select>
                        </div>
                        <div class="control-group" style="margin-bottom: 10px;">
                            <label>Calculation Mode</label>
                            <select id="beltCalcMode" style="width: 100%; padding: 6px; border-radius: 6px; border: 1px solid rgba(89,0,0,0.3); background: rgba(0,0,0,0.3); color: #fff;">
                                <option value="findBelt">Find Belt Size (enter pulleys & distance)</option>
                                <option value="findDistance">Find Distance (enter pulleys & belt)</option>
                                <option value="findPulleys">Find Pulleys (enter belt, distance & ratio)</option>
                            </select>
                        </div>

                        <div class="control-group" style="margin-bottom: 10px;">
                            <label>Use Shooter Config</label>
                            <select id="beltUseShooterConfig" style="width: 100%; padding: 6px; border-radius: 6px; border: 1px solid rgba(89,0,0,0.3); background: rgba(0,0,0,0.3); color: #fff;">
                                <option value="manual">Manual Entry</option>
                                <option value="motor-main">Motor → Main Wheel</option>
                                <option value="main-back">Main → Back Wheel (Single Motor)</option>
                                <option value="back-motor-wheel">Back Motor → Back Wheel (Dual Motor)</option>
                            </select>
                        </div>

                        <div id="beltInputs">
                            <div class="control-group" style="margin-bottom: 8px;" id="beltDriveGroup">
                                <label>Drive Pulley <small id="beltDriveMinLabel" style="color: #888;">min 12T</small></label>
                                <div style="display: flex; gap: 6px; margin-bottom: 4px;">
                                    <select id="beltDriveBore" style="flex: 1; padding: 4px; border-radius: 4px; border: 1px solid rgba(89,0,0,0.3); background: rgba(0,0,0,0.3); color: #fff; font-size: 0.85em;">
                                        <option value="spline" data-min="12">Kraken Spline</option>
                                        <option value="hex12" data-min="14">1/2" Hex</option>
                                        <option value="hex38" data-min="10">3/8" Hex</option>
                                    </select>
                                    <input type="number" id="beltDriveTeeth" value="12" min="12" max="72" style="width: 60px; padding: 4px; border-radius: 4px; border: 1px solid rgba(89,0,0,0.3); background: rgba(0,0,0,0.3); color: #cc3333; font-weight: bold; text-align: center;">
                                    <span style="color: #888; align-self: center;">T</span>
                                </div>
                            </div>
                            <div class="control-group" style="margin-bottom: 8px;" id="beltDrivenGroup">
                                <label>Driven Pulley <small id="beltDrivenMinLabel" style="color: #888;">min 14T</small></label>
                                <div style="display: flex; gap: 6px; margin-bottom: 4px;">
                                    <select id="beltDrivenBore" style="flex: 1; padding: 4px; border-radius: 4px; border: 1px solid rgba(89,0,0,0.3); background: rgba(0,0,0,0.3); color: #fff; font-size: 0.85em;">
                                        <option value="hex12" data-min="14">1/2" Hex</option>
                                        <option value="hex38" data-min="10">3/8" Hex</option>
                                        <option value="spline" data-min="12">Kraken Spline</option>
                                    </select>
                                    <input type="number" id="beltDrivenTeeth" value="18" min="14" max="72" style="width: 60px; padding: 4px; border-radius: 4px; border: 1px solid rgba(89,0,0,0.3); background: rgba(0,0,0,0.3); color: #cc3333; font-weight: bold; text-align: center;">
                                    <span style="color: #888; align-self: center;">T</span>
                                </div>
                            </div>
                            <div class="control-group" style="margin-bottom: 8px;" id="beltDistanceGroup">
                                <label>Center-to-Center Distance (inches)</label>
                                <input type="number" id="beltDistance" value="3.3125" min="0.5" max="24" step="0.0001" style="width: 100%; padding: 6px; border-radius: 6px; border: 1px solid rgba(89,0,0,0.3); background: rgba(0,0,0,0.3); color: #cc3333; font-weight: bold;">
                            </div>
                            <div class="control-group" style="margin-bottom: 8px; display: none;" id="beltLengthGroup">
                                <label>Belt Length (teeth or mm)</label>
                                <input type="number" id="beltLength" value="250" min="50" max="2000" style="width: 100%; padding: 6px; border-radius: 6px; border: 1px solid rgba(89,0,0,0.3); background: rgba(0,0,0,0.3); color: #cc3333; font-weight: bold;">
                                <small style="color: #888;">Enter teeth count (e.g., 50) or mm length (e.g., 250)</small>
                            </div>
                            <div class="control-group" style="margin-bottom: 8px; display: none;" id="beltRatioGroup">
                                <label>Desired Ratio (driven:drive, e.g., 1.5)</label>
                                <input type="number" id="beltRatio" value="1.5" min="0.25" max="6" step="0.01" style="width: 100%; padding: 6px; border-radius: 6px; border: 1px solid rgba(89,0,0,0.3); background: rgba(0,0,0,0.3); color: #cc3333; font-weight: bold;">
                            </div>
                            <div class="control-group" style="margin-bottom: 8px; display: none;" id="belt3DPrintGroup">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="belt3DPrintable" style="width: 16px; height: 16px; accent-color: #590000;">
                                    <span>3D Printable Pulleys (all tooth counts 10-72)</span>
                                </label>
                                <small style="color: #888;">Find optimal pulley sizes for exact distance match</small>
                            </div>
                        </div>

                        <button id="calculateBeltBtn" style="display: none;">Calculate</button>

                        <div id="beltResult" style="margin-top: 12px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                            <div style="color: #cc3333; font-weight: bold; margin-bottom: 8px;">Results:</div>
                            <div id="beltResultContent" style="font-size: 0.9em; line-height: 1.6;"></div>
                        </div>

                        <div style="margin-top: 10px; font-size: 0.75em; color: #888;">
                            <strong>Common Belt Sizes (5M):</strong> 200, 225, 250, 275, 300, 325, 350, 375, 400, 425, 450, 475, 500mm
                        </div>
                    </div>
                </div>

                <h2>Drive Configuration</h2>
                <div class="control-group">
                    <label>Motor Setup</label>
                    <select id="motorSetup" style="width: 100%;">
                        <option value="single">Single Motor (Pulley to both wheels)</option>
                        <option value="dual">Dual Motor (Independent control)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Ratio Type</label>
                    <select id="ratioType" style="width: 100%;">
                        <option value="pulley">Pulley (Teeth)</option>
                        <option value="gear">Gear Ratio (e.g., 2:1)</option>
                    </select>
                </div>

                <div class="section-divider">
                    <h2>Main Wheel Motor</h2>
                </div>
                <div class="control-group">
                    <label>Motor Type</label>
                    <select id="mainMotorType" style="width: 100%;">
                        <option value="x60">Kraken X60 (6000 RPM, 7.09 Nm)</option>
                        <option value="x44">Kraken X44 (7758 RPM, 4.11 Nm)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Main Motor Voltage</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="mainVoltageInput" min="0" max="12" step="0.1" value="12">
                            <span class="unit">V</span>
                        </div>
                        <input type="range" id="mainVoltageSlider" min="0" max="12" step="0.1" value="12">
                    </div>
                </div>
                <div class="control-group checkbox-group">
                    <input type="checkbox" id="mainUseFOC">
                    <label for="mainUseFOC">FOC Mode (main motor)</label>
                </div>

                <div class="section-divider" id="backMotorSection">
                    <h2>Back Wheel Motor</h2>
                </div>
                <div class="control-group" id="backMotorTypeGroup">
                    <label>Motor Type</label>
                    <select id="backMotorType" style="width: 100%;">
                        <option value="x60">Kraken X60 (6000 RPM, 7.09 Nm)</option>
                        <option value="x44">Kraken X44 (7758 RPM, 4.11 Nm)</option>
                    </select>
                </div>
                <div class="control-group" id="backVoltageGroup">
                    <label>Back Motor Voltage</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="backVoltageInput" min="0" max="12" step="0.1" value="12">
                            <span class="unit">V</span>
                        </div>
                        <input type="range" id="backVoltageSlider" min="0" max="12" step="0.1" value="12">
                    </div>
                </div>
                <div class="control-group checkbox-group" id="backFOCGroup">
                    <input type="checkbox" id="backUseFOC">
                    <label for="backUseFOC">FOC Mode (back motor)</label>
                </div>

                <div class="section-divider">
                    <h2>Main Drive Wheel</h2>
                </div>
                <div class="control-group">
                    <label>Wheel Diameter (inches)</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="mainWheelDiaInput" min="1" max="8" step="0.125" value="4">
                            <span class="unit">in</span>
                            <select id="mainWheelDiaPreset" style="margin-left: auto;">
                                <option value="">Custom</option>
                                <option value="2.875">2-7/8"</option>
                                <option value="3">3"</option>
                                <option value="4" selected>4"</option>
                                <option value="5">5"</option>
                                <option value="6">6"</option>
                            </select>
                        </div>
                        <input type="range" id="mainWheelDiaSlider" min="1" max="8" step="0.125" value="4">
                    </div>
                </div>
                <div class="control-group pulley-input" id="mainMotorPulleyGroup">
                    <label>Motor Pulley Teeth</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="motorPulleyTeethInput" min="8" max="72" step="1" value="18">
                            <span class="unit">teeth</span>
                        </div>
                        <input type="range" id="motorPulleyTeethSlider" min="8" max="72" step="1" value="18">
                    </div>
                </div>
                <div class="control-group pulley-input" id="mainWheelPulleyGroup">
                    <label>Main Wheel Pulley Teeth</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="mainPulleyTeethInput" min="8" max="72" step="1" value="36">
                            <span class="unit">teeth</span>
                        </div>
                        <input type="range" id="mainPulleyTeethSlider" min="8" max="72" step="1" value="36">
                    </div>
                </div>
                <div class="control-group gear-input" id="mainGearRatioGroup" style="display: none;">
                    <label>Main Wheel Gear Ratio (Motor:Wheel)</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="mainGearRatioInput" min="0.1" max="10" step="0.1" value="2">
                            <span class="unit">:1</span>
                        </div>
                        <input type="range" id="mainGearRatioSlider" min="0.1" max="10" step="0.1" value="2">
                    </div>
                    <small style="color: #888;">e.g., 2:1 means motor spins 2x faster than wheel</small>
                </div>

                <div class="section-divider">
                    <h2>Surface Speed Matching</h2>
                </div>
                <div class="control-group checkbox-group">
                    <input type="checkbox" id="matchSurfaceSpeeds">
                    <label for="matchSurfaceSpeeds">Match Surface Speeds (no spin)</label>
                </div>
                <div id="matchedSpeedInfo" style="display: none; background: rgba(0, 255, 136, 0.1); border: 1px solid rgba(0, 255, 136, 0.3); border-radius: 8px; padding: 10px; margin-bottom: 15px; font-size: 0.85em;">
                    <div style="color: #00ff88; font-weight: bold; margin-bottom: 8px;">Config for Equal Surface Speed (No Spin):</div>
                    <div id="matchedTargetRPM" style="color: #fff; margin-bottom: 8px; padding: 5px; background: rgba(0,0,0,0.2); border-radius: 4px;"></div>
                    <div id="matchedX60Section" style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px; margin-top: 8px;">
                        <div style="color: #590000; font-weight: bold; margin-bottom: 5px;">If using X60 on back (6048 RPM):</div>
                        <div id="matchedX60Config" style="color: #aaa;"></div>
                    </div>
                    <div id="matchedX44Section" style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px; margin-top: 8px;">
                        <div style="color: #ffaa00; font-weight: bold; margin-bottom: 5px;">If using X44 on back (7530 RPM):</div>
                        <div id="matchedX44Config" style="color: #aaa;"></div>
                    </div>
                    <div id="matchedCurrentApplied" style="color: #00ff88; margin-top: 10px; padding: 5px; background: rgba(0,255,136,0.1); border-radius: 4px;"></div>
                </div>

                <div class="section-divider">
                    <h2>Back Wheel</h2>
                </div>
                <div class="control-group">
                    <label>Wheel Diameter (inches)</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="backWheelDiaInput" min="0.25" max="4" step="0.125" value="1">
                            <span class="unit">in</span>
                            <select id="backWheelDiaPreset" style="margin-left: auto;">
                                <option value="">Custom</option>
                                <option value="0.5">0.5"</option>
                                <option value="1" selected>1"</option>
                                <option value="1.5">1.5"</option>
                                <option value="2">2"</option>
                            </select>
                        </div>
                        <input type="range" id="backWheelDiaSlider" min="0.25" max="4" step="0.125" value="1">
                    </div>
                </div>
                <div class="control-group pulley-input single-motor-only" id="backPulleyMainGroup">
                    <label>Main-to-Back Pulley Teeth (Main Side)</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="backPulleyMainTeethInput" min="8" max="72" step="1" value="24">
                            <span class="unit">teeth</span>
                        </div>
                        <input type="range" id="backPulleyMainTeethSlider" min="8" max="72" step="1" value="24">
                    </div>
                </div>
                <div class="control-group pulley-input single-motor-only" id="backPulleyBackGroup">
                    <label>Main-to-Back Pulley Teeth (Back Side)</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="backPulleyBackTeethInput" min="8" max="72" step="1" value="18">
                            <span class="unit">teeth</span>
                        </div>
                        <input type="range" id="backPulleyBackTeethSlider" min="8" max="72" step="1" value="18">
                    </div>
                </div>
                <div class="control-group gear-input single-motor-only" id="backGearRatioFromMainGroup" style="display: none;">
                    <label>Main-to-Back Gear Ratio</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="backGearRatioFromMainInput" min="0.1" max="10" step="0.1" value="1.33">
                            <span class="unit">:1</span>
                        </div>
                        <input type="range" id="backGearRatioFromMainSlider" min="0.1" max="10" step="0.1" value="1.33">
                    </div>
                    <small style="color: #888;">e.g., 1.33:1 means back wheel spins 1.33x faster than main</small>
                </div>
                <div class="control-group pulley-input dual-motor-only" id="backMotorPulleyGroup" style="display: none;">
                    <label>Back Motor Pulley Teeth</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="backMotorPulleyTeethInput" min="8" max="72" step="1" value="18">
                            <span class="unit">teeth</span>
                        </div>
                        <input type="range" id="backMotorPulleyTeethSlider" min="8" max="72" step="1" value="18">
                    </div>
                </div>
                <div class="control-group pulley-input dual-motor-only" id="backWheelPulleyGroup" style="display: none;">
                    <label>Back Wheel Pulley Teeth</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="backWheelPulleyTeethInput" min="8" max="72" step="1" value="24">
                            <span class="unit">teeth</span>
                        </div>
                        <input type="range" id="backWheelPulleyTeethSlider" min="8" max="72" step="1" value="24">
                    </div>
                </div>
                <div class="control-group gear-input dual-motor-only" id="backGearRatioGroup" style="display: none;">
                    <label>Back Wheel Gear Ratio (Motor:Wheel)</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="backGearRatioInput" min="0.1" max="10" step="0.1" value="1.5">
                            <span class="unit">:1</span>
                        </div>
                        <input type="range" id="backGearRatioSlider" min="0.1" max="10" step="0.1" value="1.5">
                    </div>
                </div>

                <div class="section-divider">
                    <h2>Wheel Mass & Flywheels</h2>
                </div>
                <div class="control-group">
                    <label>Main Wheel Mass (each)</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="mainWheelMassInput" min="0.1" max="5" step="0.1" value="1">
                            <span class="unit">lbs</span>
                        </div>
                        <input type="range" id="mainWheelMassSlider" min="0.1" max="5" step="0.1" value="1">
                    </div>
                </div>
                <div class="control-group">
                    <label>Number of Main Wheels</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="numMainWheelsInput" min="1" max="6" step="1" value="2">
                            <span class="unit">wheels</span>
                        </div>
                        <input type="range" id="numMainWheelsSlider" min="1" max="6" step="1" value="2">
                    </div>
                </div>
                <div class="control-group">
                    <label>Back Wheel Mass (each) - Sushi wheels ~0.03 lbs</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="backWheelMassInput" min="0.01" max="1" step="0.01" value="0.03">
                            <span class="unit">lbs</span>
                        </div>
                        <input type="range" id="backWheelMassSlider" min="0.01" max="1" step="0.01" value="0.03">
                    </div>
                </div>
                <div class="control-group">
                    <label>Number of Back Wheels (per stage)</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="numBackWheelsInput" min="1" max="6" step="1" value="2">
                            <span class="unit">wheels</span>
                        </div>
                        <input type="range" id="numBackWheelsSlider" min="1" max="6" step="1" value="2">
                    </div>
                </div>
                <div class="control-group">
                    <label>Number of Back Roller Stages (active hood)</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="numBackStagesInput" min="1" max="3" step="1" value="1">
                            <span class="unit">stages</span>
                        </div>
                        <input type="range" id="numBackStagesSlider" min="1" max="3" step="1" value="1">
                    </div>
                    <small style="color: #888;">2 stages = active roller hood (1.6875" c-c typical)</small>
                </div>
                <div class="control-group checkbox-group">
                    <input type="checkbox" id="useFlywheels">
                    <label for="useFlywheels">Add Flywheels (on 1/2" hex shaft)</label>
                </div>
                <div id="flywheelConfig" style="display: none; background: rgba(0,100,255,0.1); border: 1px solid rgba(0,100,255,0.3); border-radius: 8px; padding: 10px; margin-top: 10px;">
                    <div class="control-group">
                        <label>Flywheel Mass (each)</label>
                        <div class="input-slider-combo">
                            <div class="input-row">
                                <input type="number" id="flywheelMassInput" min="0.1" max="5" step="0.1" value="1">
                                <span class="unit">lbs</span>
                            </div>
                            <input type="range" id="flywheelMassSlider" min="0.1" max="5" step="0.1" value="1">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Flywheel Diameter</label>
                        <div class="input-slider-combo">
                            <div class="input-row">
                                <input type="number" id="flywheelDiaInput" min="1" max="8" step="0.5" value="4">
                                <span class="unit">in</span>
                            </div>
                            <input type="range" id="flywheelDiaSlider" min="1" max="8" step="0.5" value="4">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Number of Flywheels</label>
                        <div class="input-slider-combo">
                            <div class="input-row">
                                <input type="number" id="numFlywheelsInput" min="1" max="4" step="1" value="1">
                                <span class="unit">pcs</span>
                            </div>
                            <input type="range" id="numFlywheelsSlider" min="1" max="4" step="1" value="1">
                        </div>
                    </div>
                </div>

                <div class="section-divider">
                    <h2>Shaft Configuration (1/2" Hex Aluminum)</h2>
                </div>
                <div style="background: rgba(100, 100, 255, 0.1); border: 1px solid rgba(100, 100, 255, 0.3); border-radius: 8px; padding: 10px; margin-bottom: 15px; font-size: 0.85em;">
                    <div style="color: #88f;">1/2" Hex Aluminum shaft: ~0.038 lbs/inch</div>
                </div>
                <div class="control-group">
                    <label>Main Shaft Length</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="mainShaftLengthInput" min="0" max="24" step="0.5" value="6">
                            <span class="unit">in</span>
                        </div>
                        <input type="range" id="mainShaftLengthSlider" min="0" max="24" step="0.5" value="6">
                    </div>
                </div>
                <div class="control-group">
                    <label>Extra Mass on Main Shaft (pulleys, spacers, etc.)</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="mainShaftExtraMassInput" min="0" max="2" step="0.01" value="0.1">
                            <span class="unit">lbs</span>
                        </div>
                        <input type="range" id="mainShaftExtraMassSlider" min="0" max="2" step="0.01" value="0.1">
                    </div>
                </div>
                <div class="control-group">
                    <label>Back Shaft Length</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="backShaftLengthInput" min="0" max="24" step="0.5" value="4">
                            <span class="unit">in</span>
                        </div>
                        <input type="range" id="backShaftLengthSlider" min="0" max="24" step="0.5" value="4">
                    </div>
                </div>
                <div class="control-group">
                    <label>Extra Mass on Back Shaft</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="backShaftExtraMassInput" min="0" max="2" step="0.01" value="0.05">
                            <span class="unit">lbs</span>
                        </div>
                        <input type="range" id="backShaftExtraMassSlider" min="0" max="2" step="0.01" value="0.05">
                    </div>
                </div>

                <div class="section-divider">
                    <h2>Shooter Settings</h2>
                </div>
                <div class="control-group">
                    <label>Compression</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="compressionInput" min="0.1" max="2" step="0.0625" value="0.6875">
                            <span class="unit">in</span>
                        </div>
                        <input type="range" id="compressionSlider" min="0.1" max="2" step="0.0625" value="0.6875">
                    </div>
                </div>
                <div class="control-group">
                    <label>Contact Time</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="contactTimeInput" min="5" max="200" step="1" value="50">
                            <span class="unit">ms</span>
                        </div>
                        <input type="range" id="contactTimeSlider" min="5" max="200" step="1" value="50">
                    </div>
                </div>
                <div class="control-group">
                    <label>Launch Height from Ground</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="launchHeightInput" min="1" max="72" step="0.5" value="20">
                            <span class="unit">in</span>
                        </div>
                        <input type="range" id="launchHeightSlider" min="1" max="72" step="0.5" value="20">
                    </div>
                </div>
                <div class="control-group">
                    <label>Angle from Vertical (0 = straight up)</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="angleInput" min="0" max="90" step="1" value="30">
                            <span class="unit">deg</span>
                        </div>
                        <input type="range" id="angleSlider" min="0" max="90" step="1" value="30">
                    </div>
                </div>

                <div class="section-divider">
                    <h2>Simulation Settings</h2>
                </div>
                <div class="control-group">
                    <label>System Efficiency (belt/bearing losses)</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="systemEfficiencyInput" min="0.7" max="1.0" step="0.01" value="0.92">
                            <span class="unit">%</span>
                        </div>
                        <input type="range" id="systemEfficiencySlider" min="0.7" max="1.0" step="0.01" value="0.92">
                    </div>
                    <small style="color: #888;">Mechanical losses: belts, bearings. Typical: 90-95%</small>
                </div>
                <div class="control-group">
                    <label>Wheel Grip Factor (energy transfer to ball)</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="wheelGripInput" min="0.7" max="1.0" step="0.01" value="0.95">
                            <span class="unit">%</span>
                        </div>
                        <input type="range" id="wheelGripSlider" min="0.7" max="1.0" step="0.01" value="0.95">
                    </div>
                    <small style="color: #888;">Soft wheels (45A): ~95%. Hard wheels: ~85%. Slippage reduces this.</small>
                </div>
                <div class="control-group checkbox-group">
                    <input type="checkbox" id="includeAirDrag" checked>
                    <label for="includeAirDrag">Include Air Drag</label>
                </div>
                <div class="control-group checkbox-group">
                    <input type="checkbox" id="autoPowerMode">
                    <label for="autoPowerMode">Auto Power Mode (hit goal center)</label>
                </div>
                <div id="autoPowerStatus" style="display: none; margin-bottom: 15px; padding: 10px; border-radius: 8px; background: rgba(0,0,0,0.3);">
                    <div id="autoPowerResult" style="font-size: 0.9em;"></div>
                </div>
                <div class="control-group checkbox-group">
                    <input type="checkbox" id="animateBalls">
                    <label for="animateBalls">Animate Ball Flight</label>
                </div>
                <div id="animationControls" style="display: none;">
                    <div class="control-group">
                        <label>Balls Per Second</label>
                        <div class="input-slider-combo">
                            <div class="input-row">
                                <input type="number" id="ballsPerSecInput" min="1" max="20" step="0.1" value="12">
                                <span class="unit">BPS</span>
                            </div>
                            <input type="range" id="ballsPerSecSlider" min="1" max="20" step="0.1" value="12">
                        </div>
                        <div style="margin-top: 6px;">
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 0.9em;">
                                <input type="checkbox" id="autoBPSCheckbox" style="width: 16px; height: 16px; accent-color: #00ff88;">
                                <span>Auto-adjust (no clipping)</span>
                            </label>
                            <div id="autoBPSResult" style="display: none; margin-top: 4px; padding: 4px 8px; background: rgba(0,255,136,0.1); border-radius: 4px; font-size: 0.85em; color: #00ff88;"></div>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Animation Speed</label>
                        <div class="input-slider-combo">
                            <div class="input-row">
                                <input type="number" id="animSpeedInput" min="0.1" max="2" step="0.1" value="1">
                                <span class="unit">x</span>
                            </div>
                            <input type="range" id="animSpeedSlider" min="0.1" max="2" step="0.1" value="1">
                        </div>
                    </div>
                    <button id="startAnimBtn" style="width: 100%; padding: 10px; background: #590000; color: #fff; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; margin-top: 10px;">Start Animation</button>
                    <button id="stopAnimBtn" style="width: 100%; padding: 10px; background: #ff4444; color: #fff; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; margin-top: 5px; display: none;">Stop Animation</button>
                </div>
            </div>

            <!-- Center Panel - Trajectory Canvas -->
            <div class="panel canvas-container">
                <canvas id="trajectoryCanvas"></canvas>
            </div>

            <!-- Right Panel - Results & Goal Settings -->
            <div class="panel results-panel">
                <h2>Goal Settings</h2>
                <div class="control-group">
                    <label>Distance to Goal Center</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="goalDistanceInput" min="12" max="480" step="1" value="120">
                            <span class="unit">in</span>
                        </div>
                        <input type="range" id="goalDistanceSlider" min="12" max="480" step="1" value="120">
                    </div>
                </div>
                <div class="control-group">
                    <label>Goal Height - Bottom (from ground)</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="goalBottomHeightInput" min="6" max="144" step="1" value="78">
                            <span class="unit">in</span>
                        </div>
                        <input type="range" id="goalBottomHeightSlider" min="6" max="144" step="1" value="78">
                    </div>
                </div>
                <div class="control-group">
                    <label>Goal Opening Height (vertical)</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="goalSizeInput" min="4" max="60" step="1" value="24">
                            <span class="unit">in</span>
                        </div>
                        <input type="range" id="goalSizeSlider" min="4" max="60" step="1" value="24">
                    </div>
                </div>
                <div class="control-group">
                    <label>Goal Opening Width (horizontal)</label>
                    <div class="input-slider-combo">
                        <div class="input-row">
                            <input type="number" id="goalWidthInput" min="6" max="60" step="1" value="48">
                            <span class="unit">in</span>
                        </div>
                        <input type="range" id="goalWidthSlider" min="6" max="60" step="1" value="48">
                    </div>
                    <small style="color: #888;">Hub is 48" (4 ft) wide - Ball is 5.91"</small>
                </div>

                <div class="section-divider">
                    <h2>Calculated Results</h2>
                </div>

                <div class="results-grid">
                    <div class="result-item">
                        <div class="label">Motor RPM</div>
                        <div class="value" id="resultMotorRPM">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Main Wheel RPM</div>
                        <div class="value" id="resultMainRPM">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Main Surface Speed</div>
                        <div class="value" id="resultMainSpeed">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Back Surface Speed</div>
                        <div class="value" id="resultBackSpeed">-</div>
                    </div>
                    <div class="result-item full-width">
                        <div class="label">Surface Speed Difference</div>
                        <div class="value" id="resultSpeedDiff">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Exit Velocity</div>
                        <div class="value" id="resultExitVel">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Ball Spin</div>
                        <div class="value" id="resultSpin">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Max Height</div>
                        <div class="value" id="resultMaxHeight">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Max Distance</div>
                        <div class="value" id="resultMaxDist">-</div>
                    </div>
                    <div class="result-item full-width">
                        <div class="label">Goal Status</div>
                        <div class="value" id="resultGoalStatus">-</div>
                    </div>
                    <div class="result-item full-width">
                        <div class="label">Height at Goal</div>
                        <div class="value" id="resultHeightAtGoal">-</div>
                    </div>
                    <div class="result-item full-width">
                        <div class="label">Horizontal Margin (goal width - ball)</div>
                        <div class="value" id="resultHorizMargin">-</div>
                    </div>
                </div>

                <div class="section-divider">
                    <h2>Pulley Ratios</h2>
                </div>
                <div class="results-grid">
                    <div class="result-item">
                        <div class="label">Motor → Main</div>
                        <div class="value" id="resultMainRatio">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Main → Back</div>
                        <div class="value" id="resultBackRatio">-</div>
                    </div>
                </div>

                <div class="section-divider">
                    <h2>Spin-Up & Recovery</h2>
                </div>
                <div class="results-grid">
                    <div class="result-item">
                        <div class="label">Total Main Shaft Inertia</div>
                        <div class="value" id="resultInertia">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Main Shaft Total Weight</div>
                        <div class="value" id="resultShaftWeight">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Spin-Up Time (0 to target)</div>
                        <div class="value" id="resultSpinUpTime">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Energy per Shot</div>
                        <div class="value" id="resultBallEnergy">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">RPM Drop per Shot</div>
                        <div class="value" id="resultRPMDrop">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Recovery Time</div>
                        <div class="value" id="resultRecoveryTime">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">% Speed Loss</div>
                        <div class="value" id="resultPercentLoss">-</div>
                    </div>
                </div>

                <div class="section-divider">
                    <h2>Multi-Shot Analysis</h2>
                </div>
                <div class="results-grid">
                    <div class="result-item">
                        <div class="label">6 Shots - Min RPM</div>
                        <div class="value" id="result6ShotMin">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">6 Shots - Avg Drop</div>
                        <div class="value" id="result6ShotAvgDrop">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">20 Shots - Min RPM</div>
                        <div class="value" id="result20ShotMin">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">20 Shots - Avg Drop</div>
                        <div class="value" id="result20ShotAvgDrop">-</div>
                    </div>
                    <div class="result-item full-width" style="background: rgba(255, 136, 0, 0.2);">
                        <div class="label">Sustained Fire Capability</div>
                        <div class="value" id="resultSustainedFire">-</div>
                    </div>
                </div>

                <div class="section-divider">
                    <h2>Thermal Analysis</h2>
                </div>
                <div class="results-grid">
                    <div class="result-item">
                        <div class="label">Main Motor Heat Gen</div>
                        <div class="value" id="resultMainHeat">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Back Motor Heat Gen</div>
                        <div class="value" id="resultBackHeat">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Est. Temp Rise (30s)</div>
                        <div class="value" id="resultTempRise30">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Est. Temp Rise (2min)</div>
                        <div class="value" id="resultTempRise2min">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">RPM Loss @ +40°C</div>
                        <div class="value" id="resultRPMLossThermal">-</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Shot Velocity Change</div>
                        <div class="value" id="resultVelLossThermal">-</div>
                    </div>
                    <div class="result-item full-width" style="background: rgba(255, 100, 100, 0.2);">
                        <div class="label">Thermal Rating</div>
                        <div class="value" id="resultThermalRating">-</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Official WCProducts Motor Specs (2024)
        // X60: https://docs.wcproducts.com/welcome/electronics/kraken-x60/kraken-x60-motor/overview-and-features/motor-performance
        // X44: https://docs.wcproducts.com/welcome/electronics/kraken-x44/kraken-x44-motor/overview-and-features/motor-performance
        const MOTORS = {
            x60: {
                name: 'Kraken X60',
                // Trapezoidal: 6000 RPM free, 7.09 Nm stall, 1108W peak, 87% eff
                // FOC: 5800 RPM free, 9.37 Nm stall, 1405W peak, 85.4% eff
                freeSpeedTrap: 6000,
                freeSpeedFOC: 5800,
                kvStandard: 500,      // 6000/12
                kvFOC: 483.33,        // 5800/12
                stallTorqueTrap: 7.09,
                stallTorqueFOC: 9.37,
                maxEfficiency: 0.87
            },
            x44: {
                name: 'Kraken X44',
                // Trapezoidal: 7758 RPM free, 4.11 Nm stall, 835W peak, 81% eff
                // FOC: 7368 RPM free, 5.01 Nm stall, 966W peak, 81% eff
                freeSpeedTrap: 7758,
                freeSpeedFOC: 7368,
                kvStandard: 646.5,    // 7758/12
                kvFOC: 614,           // 7368/12
                stallTorqueTrap: 4.11,
                stallTorqueFOC: 5.01,
                maxEfficiency: 0.81
            }
        };

        // System efficiency factor (accounts for belt slip, bearing friction, voltage sag)
        // Typical real-world losses: 5-15% below theoretical
        const DEFAULT_SYSTEM_EFFICIENCY = 0.92; // 92% of theoretical speed

        // 1/2" Hex Aluminum Shaft specs
        // Hex: 0.5" across flats, aluminum density ~0.098 lb/in³
        // Cross-sectional area of 0.5" hex ≈ 0.217 in²
        // Weight per inch ≈ 0.217 * 0.098 ≈ 0.021 lb/in (theoretical)
        // Real-world WCP/Vex hex shaft is about 0.038 lb/inch
        const HEX_SHAFT_WEIGHT_PER_INCH = 0.038; // lbs per inch
        const HEX_SHAFT_RADIUS = 0.25; // inches (0.5" across flats / 2)

        // Thermal constants for Kraken motors
        // Thermal mass estimated ~150-200 J/°C for small brushless motors
        // Copper resistance increases ~0.4% per °C (affects torque/speed)
        const MOTOR_THERMAL_MASS = 180; // J/°C (heat capacity)
        const MOTOR_THERMAL_RESISTANCE = 2.5; // °C/W (heat dissipation to ambient, with some airflow)
        const COPPER_TEMP_COEFF = 0.004; // 0.4% resistance increase per °C
        const AMBIENT_TEMP = 25; // °C

        const BALL_DIAMETER_IN = 5.91;
        const BALL_WEIGHT_LBS = 0.474;
        const BALL_WEIGHT_KG = BALL_WEIGHT_LBS * 0.453592;
        const BALL_RADIUS_M = (BALL_DIAMETER_IN / 2) * 0.0254;
        const GRAVITY = 9.81;
        const AIR_DENSITY = 1.225;
        const ESTIMATED_DUROMETER = 30;

        // Synced input/slider pairs
        const syncedControls = [
            { input: 'mainVoltageInput', slider: 'mainVoltageSlider' },
            { input: 'backVoltageInput', slider: 'backVoltageSlider' },
            { input: 'mainWheelDiaInput', slider: 'mainWheelDiaSlider', preset: 'mainWheelDiaPreset' },
            { input: 'motorPulleyTeethInput', slider: 'motorPulleyTeethSlider' },
            { input: 'mainPulleyTeethInput', slider: 'mainPulleyTeethSlider' },
            { input: 'mainGearRatioInput', slider: 'mainGearRatioSlider' },
            { input: 'backWheelDiaInput', slider: 'backWheelDiaSlider', preset: 'backWheelDiaPreset' },
            { input: 'backPulleyMainTeethInput', slider: 'backPulleyMainTeethSlider' },
            { input: 'backPulleyBackTeethInput', slider: 'backPulleyBackTeethSlider' },
            { input: 'backGearRatioFromMainInput', slider: 'backGearRatioFromMainSlider' },
            { input: 'backMotorPulleyTeethInput', slider: 'backMotorPulleyTeethSlider' },
            { input: 'backWheelPulleyTeethInput', slider: 'backWheelPulleyTeethSlider' },
            { input: 'backGearRatioInput', slider: 'backGearRatioSlider' },
            { input: 'compressionInput', slider: 'compressionSlider' },
            { input: 'contactTimeInput', slider: 'contactTimeSlider' },
            { input: 'launchHeightInput', slider: 'launchHeightSlider' },
            { input: 'angleInput', slider: 'angleSlider' },
            { input: 'goalDistanceInput', slider: 'goalDistanceSlider' },
            { input: 'goalBottomHeightInput', slider: 'goalBottomHeightSlider' },
            { input: 'goalSizeInput', slider: 'goalSizeSlider' },
            { input: 'goalWidthInput', slider: 'goalWidthSlider' },
            // Wheel mass controls
            { input: 'mainWheelMassInput', slider: 'mainWheelMassSlider' },
            { input: 'numMainWheelsInput', slider: 'numMainWheelsSlider' },
            { input: 'backWheelMassInput', slider: 'backWheelMassSlider' },
            { input: 'numBackWheelsInput', slider: 'numBackWheelsSlider' },
            // Flywheel controls
            { input: 'flywheelMassInput', slider: 'flywheelMassSlider' },
            { input: 'flywheelDiaInput', slider: 'flywheelDiaSlider' },
            { input: 'numFlywheelsInput', slider: 'numFlywheelsSlider' },
            // Animation controls
            { input: 'ballsPerSecInput', slider: 'ballsPerSecSlider' },
            { input: 'animSpeedInput', slider: 'animSpeedSlider' },
            { input: 'systemEfficiencyInput', slider: 'systemEfficiencySlider' },
            { input: 'wheelGripInput', slider: 'wheelGripSlider' },
            // Shaft configuration
            { input: 'mainShaftLengthInput', slider: 'mainShaftLengthSlider' },
            { input: 'mainShaftExtraMassInput', slider: 'mainShaftExtraMassSlider' },
            { input: 'backShaftLengthInput', slider: 'backShaftLengthSlider' },
            { input: 'backShaftExtraMassInput', slider: 'backShaftExtraMassSlider' },
            { input: 'numBackStagesInput', slider: 'numBackStagesSlider' }
        ];

        // Setup syncing between inputs and sliders
        syncedControls.forEach(pair => {
            const input = document.getElementById(pair.input);
            const slider = document.getElementById(pair.slider);
            const preset = pair.preset ? document.getElementById(pair.preset) : null;

            // Sync slider -> input
            slider.addEventListener('input', () => {
                input.value = slider.value;
                if (preset) preset.value = '';  // Clear preset when manually adjusting
                calculate();
            });

            // Sync input -> slider
            input.addEventListener('input', () => {
                slider.value = input.value;
                if (preset) preset.value = '';  // Clear preset when manually adjusting
                calculate();
            });

            input.addEventListener('change', () => {
                // Clamp value to valid range
                let val = parseFloat(input.value);
                const min = parseFloat(input.min);
                const max = parseFloat(input.max);
                if (val < min) val = min;
                if (val > max) val = max;
                input.value = val;
                slider.value = val;
                calculate();
            });

            // Handle preset dropdowns
            if (preset) {
                preset.addEventListener('change', () => {
                    if (preset.value) {
                        input.value = preset.value;
                        slider.value = preset.value;
                        calculate();
                    }
                });
            }
        });

        // Checkbox controls
        document.getElementById('mainUseFOC').addEventListener('change', calculate);
        document.getElementById('backUseFOC').addEventListener('change', calculate);

        // Flywheel toggle
        document.getElementById('useFlywheels').addEventListener('change', function() {
            document.getElementById('flywheelConfig').style.display = this.checked ? 'block' : 'none';
            calculate();
        });

        // Air drag toggle
        document.getElementById('includeAirDrag').addEventListener('change', calculate);

        // Auto Power Mode toggle
        document.getElementById('autoPowerMode').addEventListener('change', function() {
            document.getElementById('autoPowerStatus').style.display = this.checked ? 'block' : 'none';
            // Disable manual voltage controls when auto power is on
            const mainVoltageInput = document.getElementById('mainVoltageInput');
            const mainVoltageSlider = document.getElementById('mainVoltageSlider');
            const backVoltageInput = document.getElementById('backVoltageInput');
            const backVoltageSlider = document.getElementById('backVoltageSlider');

            mainVoltageInput.disabled = this.checked;
            mainVoltageSlider.disabled = this.checked;
            backVoltageInput.disabled = this.checked;
            backVoltageSlider.disabled = this.checked;

            if (this.checked) {
                mainVoltageInput.style.opacity = '0.5';
                mainVoltageSlider.style.opacity = '0.5';
                backVoltageInput.style.opacity = '0.5';
                backVoltageSlider.style.opacity = '0.5';
            } else {
                mainVoltageInput.style.opacity = '1';
                mainVoltageSlider.style.opacity = '1';
                backVoltageInput.style.opacity = '1';
                backVoltageSlider.style.opacity = '1';
            }
            calculate();
        });

        // Animation toggle
        document.getElementById('animateBalls').addEventListener('change', function() {
            document.getElementById('animationControls').style.display = this.checked ? 'block' : 'none';
            if (!this.checked) {
                stopAnimation();
            }
        });

        // Animation buttons
        document.getElementById('startAnimBtn').addEventListener('click', startAnimation);
        document.getElementById('stopAnimBtn').addEventListener('click', stopAnimation);

        // Select controls
        document.getElementById('mainMotorType').addEventListener('change', calculate);
        document.getElementById('backMotorType').addEventListener('change', calculate);

        // Motor setup toggle (single vs dual)
        function updateMotorSetupVisibility() {
            const motorSetup = document.getElementById('motorSetup').value;
            const isDual = motorSetup === 'dual';

            // Back motor independent controls (only show in dual mode)
            document.getElementById('backMotorSection').style.display = isDual ? '' : 'none';
            document.getElementById('backMotorTypeGroup').style.display = isDual ? '' : 'none';
            document.getElementById('backVoltageGroup').style.display = isDual ? '' : 'none';
            document.getElementById('backFOCGroup').style.display = isDual ? '' : 'none';

            // Single motor pulley from main to back (only in single mode)
            document.querySelectorAll('.single-motor-only').forEach(el => {
                el.style.display = isDual ? 'none' : '';
            });

            // Dual motor back wheel controls
            document.querySelectorAll('.dual-motor-only').forEach(el => {
                el.style.display = isDual ? '' : 'none';
            });

            updateRatioTypeVisibility();
            calculate();
        }

        // Ratio type toggle (pulley vs gear)
        function updateRatioTypeVisibility() {
            const ratioType = document.getElementById('ratioType').value;
            const motorSetup = document.getElementById('motorSetup').value;
            const isPulley = ratioType === 'pulley';
            const isDual = motorSetup === 'dual';

            // Main wheel ratio controls
            document.getElementById('mainMotorPulleyGroup').style.display = isPulley ? '' : 'none';
            document.getElementById('mainWheelPulleyGroup').style.display = isPulley ? '' : 'none';
            document.getElementById('mainGearRatioGroup').style.display = isPulley ? 'none' : '';

            // Back wheel ratio controls (depends on single vs dual)
            if (!isDual) {
                // Single motor mode - show main-to-back ratio
                document.getElementById('backPulleyMainGroup').style.display = isPulley ? '' : 'none';
                document.getElementById('backPulleyBackGroup').style.display = isPulley ? '' : 'none';
                document.getElementById('backGearRatioFromMainGroup').style.display = isPulley ? 'none' : '';
            } else {
                // Dual motor mode - show back motor ratio
                document.getElementById('backMotorPulleyGroup').style.display = isPulley ? '' : 'none';
                document.getElementById('backWheelPulleyGroup').style.display = isPulley ? '' : 'none';
                document.getElementById('backGearRatioGroup').style.display = isPulley ? 'none' : '';
            }

            calculate();
        }

        document.getElementById('motorSetup').addEventListener('change', updateMotorSetupVisibility);
        document.getElementById('ratioType').addEventListener('change', updateRatioTypeVisibility);

        // Surface speed matching
        document.getElementById('matchSurfaceSpeeds').addEventListener('change', function() {
            const infoDiv = document.getElementById('matchedSpeedInfo');
            if (this.checked) {
                infoDiv.style.display = 'block';
                calculateMatchedSpeeds();
            } else {
                infoDiv.style.display = 'none';
            }
            calculate();
        });

        function calculateMatchedSpeeds() {
            const motorSetup = document.getElementById('motorSetup').value;
            const ratioType = document.getElementById('ratioType').value;
            const mainWheelDia = parseFloat(document.getElementById('mainWheelDiaInput').value);
            const backWheelDia = parseFloat(document.getElementById('backWheelDiaInput').value);
            const mainVoltage = parseFloat(document.getElementById('mainVoltageInput').value);
            const mainMotorType = document.getElementById('mainMotorType').value;
            const mainUseFOC = document.getElementById('mainUseFOC').checked;

            // Get main wheel gear ratio
            let mainGearRatio;
            if (ratioType === 'pulley') {
                const motorTeeth = parseInt(document.getElementById('motorPulleyTeethInput').value);
                const wheelTeeth = parseInt(document.getElementById('mainPulleyTeethInput').value);
                mainGearRatio = motorTeeth / wheelTeeth;
            } else {
                mainGearRatio = 1 / parseFloat(document.getElementById('mainGearRatioInput').value);
            }

            // Calculate main wheel RPM and surface speed
            const mainMotor = MOTORS[mainMotorType];
            const mainKv = mainUseFOC ? mainMotor.kvFOC : mainMotor.kvStandard;
            const mainMotorRPM = mainVoltage * mainKv;
            const mainWheelRPM = mainMotorRPM * mainGearRatio;
            const mainSurfaceSpeed = Math.PI * mainWheelDia * mainWheelRPM / 60;

            // For equal surface speed: backSurfaceSpeed = mainSurfaceSpeed
            // π × backDia × backRPM / 60 = mainSurfaceSpeed
            // backRPM = mainSurfaceSpeed × 60 / (π × backDia)
            const targetBackRPM = mainSurfaceSpeed * 60 / (Math.PI * backWheelDia);

            let pulleyInfo = '';
            let gearInfo = '';
            let voltageInfo = '';

            if (motorSetup === 'single') {
                // Single motor: need to find main-to-back ratio
                // backRPM = mainWheelRPM × mainToBackRatio
                const requiredRatio = targetBackRPM / mainWheelRPM;

                // For pulley: ratio = mainTeeth / backTeeth
                // Common pulley teeth: 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 36, 40, 44, 48, 60, 72
                const commonTeeth = [12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 36, 40, 44, 48, 60, 72];
                let bestPulleyCombo = null;
                let bestPulleyError = Infinity;

                for (const mainT of commonTeeth) {
                    for (const backT of commonTeeth) {
                        const pulleyRatio = mainT / backT;
                        const error = Math.abs(pulleyRatio - requiredRatio);
                        if (error < bestPulleyError) {
                            bestPulleyError = error;
                            bestPulleyCombo = { main: mainT, back: backT, ratio: pulleyRatio };
                        }
                    }
                }

                pulleyInfo = `Pulley: ${bestPulleyCombo.main}T (main) : ${bestPulleyCombo.back}T (back) = ${bestPulleyCombo.ratio.toFixed(3)}:1`;
                gearInfo = `Gear Ratio: ${requiredRatio.toFixed(3)}:1 (main-to-back)`;

                // Apply if checkbox is checked
                if (document.getElementById('matchSurfaceSpeeds').checked) {
                    if (ratioType === 'pulley') {
                        document.getElementById('backPulleyMainTeethInput').value = bestPulleyCombo.main;
                        document.getElementById('backPulleyMainTeethSlider').value = bestPulleyCombo.main;
                        document.getElementById('backPulleyBackTeethInput').value = bestPulleyCombo.back;
                        document.getElementById('backPulleyBackTeethSlider').value = bestPulleyCombo.back;
                    } else {
                        document.getElementById('backGearRatioFromMainInput').value = requiredRatio.toFixed(2);
                        document.getElementById('backGearRatioFromMainSlider').value = requiredRatio.toFixed(2);
                    }
                }

            } else {
                // Dual motor mode - calculate for BOTH X60 and X44 options
                const backUseFOC = document.getElementById('backUseFOC').checked;
                const currentBackMotorType = document.getElementById('backMotorType').value;
                const commonTeeth = [12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 36, 40, 44, 48, 60, 72];

                // Get current back gear ratio
                let currentBackGearRatio;
                if (ratioType === 'pulley') {
                    const backMotorTeeth = parseInt(document.getElementById('backMotorPulleyTeethInput').value);
                    const backWheelTeeth = parseInt(document.getElementById('backWheelPulleyTeethInput').value);
                    currentBackGearRatio = backMotorTeeth / backWheelTeeth;
                } else {
                    currentBackGearRatio = 1 / parseFloat(document.getElementById('backGearRatioInput').value);
                }

                // Show target back wheel RPM
                document.getElementById('matchedTargetRPM').innerHTML =
                    `<strong>Target Back Wheel RPM:</strong> ${Math.round(targetBackRPM)} RPM<br>` +
                    `<strong>Target Surface Speed:</strong> ${mainSurfaceSpeed.toFixed(1)} in/s`;

                // Calculate for X60
                const x60Kv = backUseFOC ? MOTORS.x60.kvFOC : MOTORS.x60.kvStandard;
                const x60MotorRPMat12V = 12 * x60Kv;
                const x60RequiredVoltage = (targetBackRPM / currentBackGearRatio) / x60Kv;
                const x60RequiredGearRatio = targetBackRPM / x60MotorRPMat12V;

                // Find best pulley for X60
                let x60BestPulley = { motor: 18, wheel: 36, ratio: 0.5 };
                let x60BestError = Infinity;
                for (const motorT of commonTeeth) {
                    for (const wheelT of commonTeeth) {
                        const ratio = motorT / wheelT;
                        const error = Math.abs(ratio - x60RequiredGearRatio);
                        if (error < x60BestError) {
                            x60BestError = error;
                            x60BestPulley = { motor: motorT, wheel: wheelT, ratio: ratio };
                        }
                    }
                }

                let x60Info = '';
                if (x60RequiredVoltage >= 0 && x60RequiredVoltage <= 12) {
                    x60Info += `<div style="color: #0f0;">Voltage Method: <strong>${x60RequiredVoltage.toFixed(2)}V</strong> (with current ${(1/currentBackGearRatio).toFixed(2)}:1 ratio)</div>`;
                } else {
                    x60Info += `<div style="color: #f66;">Voltage Method: ${x60RequiredVoltage.toFixed(2)}V (OUT OF RANGE)</div>`;
                }
                x60Info += `<div>Pulley Method (at 12V): <strong>${x60BestPulley.motor}T : ${x60BestPulley.wheel}T</strong> (${x60BestPulley.ratio.toFixed(3)}x)</div>`;
                x60Info += `<div>Gear Ratio (at 12V): <strong>${(1/x60RequiredGearRatio).toFixed(2)}:1</strong></div>`;
                document.getElementById('matchedX60Config').innerHTML = x60Info;

                // Calculate for X44
                const x44Kv = backUseFOC ? MOTORS.x44.kvFOC : MOTORS.x44.kvStandard;
                const x44MotorRPMat12V = 12 * x44Kv;
                const x44RequiredVoltage = (targetBackRPM / currentBackGearRatio) / x44Kv;
                const x44RequiredGearRatio = targetBackRPM / x44MotorRPMat12V;

                // Find best pulley for X44
                let x44BestPulley = { motor: 18, wheel: 36, ratio: 0.5 };
                let x44BestError = Infinity;
                for (const motorT of commonTeeth) {
                    for (const wheelT of commonTeeth) {
                        const ratio = motorT / wheelT;
                        const error = Math.abs(ratio - x44RequiredGearRatio);
                        if (error < x44BestError) {
                            x44BestError = error;
                            x44BestPulley = { motor: motorT, wheel: wheelT, ratio: ratio };
                        }
                    }
                }

                let x44Info = '';
                if (x44RequiredVoltage >= 0 && x44RequiredVoltage <= 12) {
                    x44Info += `<div style="color: #0f0;">Voltage Method: <strong>${x44RequiredVoltage.toFixed(2)}V</strong> (with current ${(1/currentBackGearRatio).toFixed(2)}:1 ratio)</div>`;
                } else {
                    x44Info += `<div style="color: #f66;">Voltage Method: ${x44RequiredVoltage.toFixed(2)}V (OUT OF RANGE)</div>`;
                }
                x44Info += `<div>Pulley Method (at 12V): <strong>${x44BestPulley.motor}T : ${x44BestPulley.wheel}T</strong> (${x44BestPulley.ratio.toFixed(3)}x)</div>`;
                x44Info += `<div>Gear Ratio (at 12V): <strong>${(1/x44RequiredGearRatio).toFixed(2)}:1</strong></div>`;
                document.getElementById('matchedX44Config').innerHTML = x44Info;

                // Apply the current motor type's configuration
                if (document.getElementById('matchSurfaceSpeeds').checked) {
                    const currentMotor = MOTORS[currentBackMotorType];
                    const currentKv = backUseFOC ? currentMotor.kvFOC : currentMotor.kvStandard;
                    const requiredVoltage = (targetBackRPM / currentBackGearRatio) / currentKv;

                    if (requiredVoltage >= 0 && requiredVoltage <= 12) {
                        document.getElementById('backVoltageInput').value = requiredVoltage.toFixed(1);
                        document.getElementById('backVoltageSlider').value = requiredVoltage.toFixed(1);
                        document.getElementById('matchedCurrentApplied').innerHTML =
                            `Applied: Back motor voltage set to <strong>${requiredVoltage.toFixed(1)}V</strong>`;
                    } else {
                        // Use gear ratio method
                        const requiredGearRatio = targetBackRPM / (12 * currentKv);
                        let bestPulley = currentBackMotorType === 'x60' ? x60BestPulley : x44BestPulley;

                        if (ratioType === 'pulley') {
                            document.getElementById('backMotorPulleyTeethInput').value = bestPulley.motor;
                            document.getElementById('backMotorPulleyTeethSlider').value = bestPulley.motor;
                            document.getElementById('backWheelPulleyTeethInput').value = bestPulley.wheel;
                            document.getElementById('backWheelPulleyTeethSlider').value = bestPulley.wheel;
                            document.getElementById('matchedCurrentApplied').innerHTML =
                                `Applied: Pulley set to <strong>${bestPulley.motor}T : ${bestPulley.wheel}T</strong> (voltage out of range)`;
                        } else {
                            const gearVal = (1/requiredGearRatio).toFixed(2);
                            document.getElementById('backGearRatioInput').value = gearVal;
                            document.getElementById('backGearRatioSlider').value = gearVal;
                            document.getElementById('matchedCurrentApplied').innerHTML =
                                `Applied: Gear ratio set to <strong>${gearVal}:1</strong> (voltage out of range)`;
                        }
                    }
                }

                // Clear single motor display elements
                pulleyInfo = '';
                gearInfo = '';
                voltageInfo = '';
            }

            // Update display based on motor setup mode
            if (motorSetup === 'single') {
                // Hide X60/X44 sections for single motor mode
                document.getElementById('matchedX60Section').style.display = 'none';
                document.getElementById('matchedX44Section').style.display = 'none';

                const requiredRatio = targetBackRPM / mainWheelRPM;
                document.getElementById('matchedTargetRPM').innerHTML =
                    `<strong>Target Back Wheel RPM:</strong> ${Math.round(targetBackRPM)} RPM<br>` +
                    `<strong>Main-to-Back Ratio Needed:</strong> ${requiredRatio.toFixed(3)}:1<br>` +
                    `<strong>Pulley:</strong> ${pulleyInfo}<br>` +
                    `<strong>Gear:</strong> ${gearInfo}`;
                document.getElementById('matchedCurrentApplied').innerHTML =
                    `<strong>Applied:</strong> Ratio set to ${requiredRatio.toFixed(3)}:1`;
            } else {
                // Show X60/X44 sections for dual motor mode
                document.getElementById('matchedX60Section').style.display = 'block';
                document.getElementById('matchedX44Section').style.display = 'block';
            }
        }

        // Recalculate matched speeds when relevant inputs change
        ['mainWheelDiaInput', 'backWheelDiaInput', 'mainVoltageInput', 'motorPulleyTeethInput',
         'mainPulleyTeethInput', 'mainGearRatioInput', 'backVoltageInput', 'backMotorPulleyTeethInput',
         'backWheelPulleyTeethInput', 'backGearRatioInput'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('input', () => {
                    if (document.getElementById('matchSurfaceSpeeds').checked) {
                        calculateMatchedSpeeds();
                    }
                });
            }
        });

        ['mainMotorType', 'backMotorType', 'motorSetup', 'ratioType'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                if (document.getElementById('matchSurfaceSpeeds').checked) {
                    calculateMatchedSpeeds();
                }
            });
        });

        ['mainUseFOC', 'backUseFOC'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                if (document.getElementById('matchSurfaceSpeeds').checked) {
                    calculateMatchedSpeeds();
                }
            });
        });

        // Canvas setup
        const canvas = document.getElementById('trajectoryCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const container = canvas.parentElement;
            const width = container.clientWidth;
            // Use viewport height minus some padding, with min of 500px
            const viewportHeight = window.innerHeight - 100;
            const height = Math.max(500, Math.min(viewportHeight, 700));

            // Set canvas internal resolution to match display size (prevents stretching)
            canvas.width = width;
            canvas.height = height;

            // Also set CSS size to match
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            calculate();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Calculator functions
        function getConfig() {
            const motorSetup = document.getElementById('motorSetup').value;
            const ratioType = document.getElementById('ratioType').value;
            const isDual = motorSetup === 'dual';
            const isPulley = ratioType === 'pulley';

            const config = {
                motorSetup: motorSetup,
                ratioType: ratioType,

                // Main motor
                mainMotorType: document.getElementById('mainMotorType').value,
                mainVoltage: parseFloat(document.getElementById('mainVoltageInput').value),
                mainUseFOC: document.getElementById('mainUseFOC').checked,

                // Main wheel
                mainWheelDia: parseFloat(document.getElementById('mainWheelDiaInput').value),

                // Back motor (dual mode)
                backMotorType: document.getElementById('backMotorType').value,
                backVoltage: parseFloat(document.getElementById('backVoltageInput').value),
                backUseFOC: document.getElementById('backUseFOC').checked,

                // Back wheel
                backWheelDia: parseFloat(document.getElementById('backWheelDiaInput').value),

                // Shooter settings
                compression: parseFloat(document.getElementById('compressionInput').value),
                contactTime: parseFloat(document.getElementById('contactTimeInput').value),
                launchHeight: parseFloat(document.getElementById('launchHeightInput').value),
                angle: parseFloat(document.getElementById('angleInput').value),

                // Goal settings
                goalDistance: parseFloat(document.getElementById('goalDistanceInput').value),
                goalBottomHeight: parseFloat(document.getElementById('goalBottomHeightInput').value),
                goalSize: parseFloat(document.getElementById('goalSizeInput').value),
                goalWidth: parseFloat(document.getElementById('goalWidthInput').value),

                // Wheel mass settings
                mainWheelMass: parseFloat(document.getElementById('mainWheelMassInput').value),
                numMainWheels: parseInt(document.getElementById('numMainWheelsInput').value),
                backWheelMass: parseFloat(document.getElementById('backWheelMassInput').value),
                numBackWheels: parseInt(document.getElementById('numBackWheelsInput').value),

                // Flywheel settings
                useFlywheels: document.getElementById('useFlywheels').checked,
                flywheelMass: parseFloat(document.getElementById('flywheelMassInput').value),
                flywheelDia: parseFloat(document.getElementById('flywheelDiaInput').value),
                numFlywheels: parseInt(document.getElementById('numFlywheelsInput').value),

                // Simulation settings
                includeAirDrag: document.getElementById('includeAirDrag').checked,
                ballsPerSec: parseInt(document.getElementById('ballsPerSecInput').value),
                animSpeed: parseFloat(document.getElementById('animSpeedInput').value),
                systemEfficiency: parseFloat(document.getElementById('systemEfficiencyInput').value),
                wheelGrip: parseFloat(document.getElementById('wheelGripInput').value),

                // Shaft configuration
                mainShaftLength: parseFloat(document.getElementById('mainShaftLengthInput').value),
                mainShaftExtraMass: parseFloat(document.getElementById('mainShaftExtraMassInput').value),
                backShaftLength: parseFloat(document.getElementById('backShaftLengthInput').value),
                backShaftExtraMass: parseFloat(document.getElementById('backShaftExtraMassInput').value),
                numBackStages: parseInt(document.getElementById('numBackStagesInput').value) || 1
            };

            // Main wheel ratio
            if (isPulley) {
                config.mainMotorPulleyTeeth = parseInt(document.getElementById('motorPulleyTeethInput').value);
                config.mainWheelPulleyTeeth = parseInt(document.getElementById('mainPulleyTeethInput').value);
                config.mainGearRatio = config.mainMotorPulleyTeeth / config.mainWheelPulleyTeeth;
            } else {
                config.mainGearRatio = 1 / parseFloat(document.getElementById('mainGearRatioInput').value);
            }

            // Back wheel ratio
            if (isDual) {
                // Dual motor mode - back motor drives back wheel
                if (isPulley) {
                    config.backMotorPulleyTeeth = parseInt(document.getElementById('backMotorPulleyTeethInput').value);
                    config.backWheelPulleyTeeth = parseInt(document.getElementById('backWheelPulleyTeethInput').value);
                    config.backGearRatio = config.backMotorPulleyTeeth / config.backWheelPulleyTeeth;
                } else {
                    config.backGearRatio = 1 / parseFloat(document.getElementById('backGearRatioInput').value);
                }
            } else {
                // Single motor mode - main wheel drives back wheel
                if (isPulley) {
                    config.backPulleyMainTeeth = parseInt(document.getElementById('backPulleyMainTeethInput').value);
                    config.backPulleyBackTeeth = parseInt(document.getElementById('backPulleyBackTeethInput').value);
                    config.mainToBackRatio = config.backPulleyMainTeeth / config.backPulleyBackTeeth;
                } else {
                    config.mainToBackRatio = parseFloat(document.getElementById('backGearRatioFromMainInput').value);
                }
            }

            return config;
        }

        function getMotorRPM(motorType, voltage, useFOC, efficiency = 1.0) {
            const motor = MOTORS[motorType];
            const kv = useFOC ? motor.kvFOC : motor.kvStandard;
            // Apply system efficiency to account for real-world losses
            return voltage * kv * efficiency;
        }

        function getMotorStallTorque(motorType, useFOC) {
            const motor = MOTORS[motorType];
            return useFOC ? motor.stallTorqueFOC : motor.stallTorqueTrap;
        }

        function calculateMainMotorRPM(config) {
            const efficiency = config.systemEfficiency || DEFAULT_SYSTEM_EFFICIENCY;
            return getMotorRPM(config.mainMotorType, config.mainVoltage, config.mainUseFOC, efficiency);
        }

        function calculateBackMotorRPM(config) {
            const efficiency = config.systemEfficiency || DEFAULT_SYSTEM_EFFICIENCY;
            if (config.motorSetup === 'dual') {
                return getMotorRPM(config.backMotorType, config.backVoltage, config.backUseFOC, efficiency);
            }
            return calculateMainMotorRPM(config);  // Single motor mode
        }

        function calculateMainWheelRPM(config) {
            const motorRPM = calculateMainMotorRPM(config);
            return motorRPM * config.mainGearRatio;
        }

        function calculateBackWheelRPM(config) {
            if (config.motorSetup === 'dual') {
                // Dual motor - back motor drives back wheel directly
                const motorRPM = calculateBackMotorRPM(config);
                return motorRPM * config.backGearRatio;
            } else {
                // Single motor - main wheel drives back wheel
                const mainRPM = calculateMainWheelRPM(config);
                return mainRPM * config.mainToBackRatio;
            }
        }

        function calculateSurfaceSpeed(diameterIn, rpm) {
            const circumference = Math.PI * diameterIn;
            const speedInPerSec = (rpm / 60) * circumference;
            const speedMPerSec = speedInPerSec * 0.0254;
            return { inPerSec: speedInPerSec, mPerSec: speedMPerSec };
        }

        function calculateExitVelocity(config, mainSpeed, backSpeed) {
            const avgSpeed = (mainSpeed.mPerSec + backSpeed.mPerSec) / 2;

            const compressionRatio = config.compression / BALL_DIAMETER_IN;
            let efficiency;
            if (compressionRatio < 0.15) {
                efficiency = 0.7 + (compressionRatio / 0.15) * 0.25;
            } else {
                efficiency = 0.95 - (compressionRatio - 0.15) * 0.5;
            }
            efficiency = Math.max(0.5, Math.min(0.98, efficiency));

            const durometerFactor = 1.0 - (ESTIMATED_DUROMETER - 30) * 0.005;

            // Wheel grip factor - accounts for slippage between wheels and ball
            const wheelGrip = config.wheelGrip || 0.95;

            return avgSpeed * efficiency * durometerFactor * wheelGrip;
        }

        function calculateBallSpin(config, mainSpeed, backSpeed) {
            const diffM = mainSpeed.mPerSec - backSpeed.mPerSec;
            const contactFactor = Math.min(1.0, config.contactTime / 100);
            return (diffM / BALL_RADIUS_M) * contactFactor * 0.7;
        }

        // Calculate moment of inertia for a solid cylinder: I = 0.5 * m * r^2
        // mass in kg, radius in meters, returns kg*m^2
        function calcCylinderInertia(massKg, radiusM) {
            return 0.5 * massKg * radiusM * radiusM;
        }

        // Calculate total system inertia for the main shooter shaft
        function calculateMainShaftInertia(config) {
            const lbsToKg = 0.453592;
            const inToM = 0.0254;

            // Main wheels inertia
            const mainWheelMassKg = config.mainWheelMass * lbsToKg;
            const mainWheelRadiusM = (config.mainWheelDia / 2) * inToM;
            const mainWheelsInertia = config.numMainWheels * calcCylinderInertia(mainWheelMassKg, mainWheelRadiusM);

            // Flywheels inertia (if enabled)
            let flywheelsInertia = 0;
            if (config.useFlywheels) {
                const flywheelMassKg = config.flywheelMass * lbsToKg;
                const flywheelRadiusM = (config.flywheelDia / 2) * inToM;
                flywheelsInertia = config.numFlywheels * calcCylinderInertia(flywheelMassKg, flywheelRadiusM);
            }

            // Shaft inertia (1/2" hex aluminum)
            const shaftLength = config.mainShaftLength || 0;
            const shaftMassLbs = shaftLength * HEX_SHAFT_WEIGHT_PER_INCH;
            const shaftMassKg = shaftMassLbs * lbsToKg;
            const shaftRadiusM = HEX_SHAFT_RADIUS * inToM;
            const shaftInertia = calcCylinderInertia(shaftMassKg, shaftRadiusM);

            // Extra mass on shaft (pulleys, spacers, etc.) - assume at shaft radius
            const extraMassKg = (config.mainShaftExtraMass || 0) * lbsToKg;
            const extraMassInertia = calcCylinderInertia(extraMassKg, shaftRadiusM * 2); // Assume ~1" effective radius

            return mainWheelsInertia + flywheelsInertia + shaftInertia + extraMassInertia;
        }

        // Calculate back wheel shaft inertia
        function calculateBackShaftInertia(config) {
            const lbsToKg = 0.453592;
            const inToM = 0.0254;
            const numStages = config.numBackStages || 1;

            // Calculate inertia for ONE back roller stage
            const backWheelMassKg = config.backWheelMass * lbsToKg;
            const backWheelRadiusM = (config.backWheelDia / 2) * inToM;
            const backWheelsInertiaPerStage = config.numBackWheels * calcCylinderInertia(backWheelMassKg, backWheelRadiusM);

            // Back shaft inertia per stage (1/2" hex aluminum)
            const shaftLength = config.backShaftLength || 0;
            const shaftMassLbs = shaftLength * HEX_SHAFT_WEIGHT_PER_INCH;
            const shaftMassKg = shaftMassLbs * lbsToKg;
            const shaftRadiusM = HEX_SHAFT_RADIUS * inToM;
            const shaftInertiaPerStage = calcCylinderInertia(shaftMassKg, shaftRadiusM);

            // Extra mass per back shaft
            const extraMassKg = (config.backShaftExtraMass || 0) * lbsToKg;
            const extraMassInertiaPerStage = calcCylinderInertia(extraMassKg, shaftRadiusM * 2);

            // Total = per-stage inertia × number of stages
            const perStageInertia = backWheelsInertiaPerStage + shaftInertiaPerStage + extraMassInertiaPerStage;
            return perStageInertia * numStages;
        }

        // Calculate energy transferred to ball during shot
        // Ball gains both linear KE and rotational KE
        function calculateBallEnergy(exitVelocity, spin) {
            // Linear KE = 0.5 * m * v^2
            const linearKE = 0.5 * BALL_WEIGHT_KG * exitVelocity * exitVelocity;

            // Rotational KE = 0.5 * I * omega^2
            // For hollow sphere: I = (2/3) * m * r^2
            const ballInertia = (2/3) * BALL_WEIGHT_KG * BALL_RADIUS_M * BALL_RADIUS_M;
            const rotationalKE = 0.5 * ballInertia * spin * spin;

            return linearKE + rotationalKE;
        }

        // Calculate RPM drop after shot
        // Energy is drawn from the rotating wheels
        function calculateRPMDropAfterShot(config, mainRPM, ballEnergy) {
            const mainInertia = calculateMainShaftInertia(config);

            // Convert RPM to rad/s
            const mainOmega = mainRPM * (2 * Math.PI / 60);

            // Initial kinetic energy of main shaft
            const initialKE = 0.5 * mainInertia * mainOmega * mainOmega;

            // After shot, energy is reduced
            const finalKE = Math.max(0, initialKE - ballEnergy);

            // Calculate new angular velocity
            const finalOmega = Math.sqrt(2 * finalKE / mainInertia);

            // Convert back to RPM
            const finalRPM = finalOmega * (60 / (2 * Math.PI));

            return {
                rpmDrop: mainRPM - finalRPM,
                finalRPM: finalRPM,
                percentDrop: ((mainRPM - finalRPM) / mainRPM) * 100
            };
        }

        // Calculate time to spin up from one RPM to another
        // Uses motor torque and gear ratio
        function calculateSpinUpTime(config, fromRPM, toRPM) {
            const motor = MOTORS[config.mainMotorType];
            const gearRatio = config.mainGearRatio;
            const stallTorque = getMotorStallTorque(config.mainMotorType, config.mainUseFOC);

            // Motor torque at wheel shaft (torque multiplied by gear ratio)
            // Using average torque estimate (50% of stall torque for loaded acceleration)
            const avgTorque = stallTorque * 0.5 / gearRatio;

            const mainInertia = calculateMainShaftInertia(config);

            // Angular acceleration = Torque / Inertia
            // alpha = T / I (rad/s^2)
            const alpha = avgTorque / mainInertia;

            // Time = delta_omega / alpha
            const deltaOmega = (toRPM - fromRPM) * (2 * Math.PI / 60);
            const time = Math.abs(deltaOmega / alpha);

            return time;
        }

        // Thermal analysis functions
        function calculateMotorHeatGeneration(motorType, useFOC, loadPercent) {
            // Heat = Power * (1 - efficiency)
            // At partial load, efficiency varies - estimate based on load percentage
            const motor = MOTORS[motorType];
            const baseEfficiency = motor.maxEfficiency;

            // Efficiency drops at very low and very high loads
            // Best efficiency around 30-50% load
            let efficiency;
            if (loadPercent < 0.2) {
                efficiency = baseEfficiency * 0.7; // Low load = poor efficiency
            } else if (loadPercent < 0.6) {
                efficiency = baseEfficiency; // Optimal range
            } else {
                efficiency = baseEfficiency * (1 - (loadPercent - 0.6) * 0.3); // High load degrades
            }

            // Estimate mechanical power output based on load
            // For a shooter at steady state, load is relatively low (maybe 10-30%)
            const freeSpeed = useFOC ? motor.freeSpeedFOC : motor.freeSpeedTrap;
            const stallTorque = useFOC ? motor.stallTorqueFOC : motor.stallTorqueTrap;

            // At steady-state shooter speed, current draw is relatively low
            // Estimate ~5-15A average for flywheel maintenance
            const estimatedCurrent = 10 + loadPercent * 30; // 10-40A depending on load
            const voltage = 12;
            const electricalPower = voltage * estimatedCurrent;
            const heatGenerated = electricalPower * (1 - efficiency);

            return {
                heatWatts: heatGenerated,
                efficiency: efficiency,
                estimatedCurrent: estimatedCurrent
            };
        }

        function calculateThermalRise(heatWatts, timeSeconds) {
            // Simplified thermal model: T_rise = P * R_th * (1 - e^(-t/tau))
            // Where tau = thermal_mass * thermal_resistance
            const tau = MOTOR_THERMAL_MASS * MOTOR_THERMAL_RESISTANCE / 100; // time constant in seconds
            const steadyStateRise = heatWatts * MOTOR_THERMAL_RESISTANCE;
            const tempRise = steadyStateRise * (1 - Math.exp(-timeSeconds / tau));
            return tempRise;
        }

        function calculateThermalRPMLoss(tempRiseC) {
            // Copper resistance increases with temperature
            // Higher resistance = less current at same voltage = less torque
            // This manifests as reduced speed under load
            // Approximate: RPM loss ≈ temp_rise * copper_coeff * base_rpm * load_factor
            const rpmLossPercent = tempRiseC * COPPER_TEMP_COEFF * 100 * 0.3; // 0.3 load factor
            return rpmLossPercent;
        }

        // Multi-shot analysis
        function analyzeMultipleShots(config, mainRPM, ballEnergy, numShots) {
            const results = [];
            let currentRPM = mainRPM;
            let totalTime = 0;
            const shotInterval = 1 / 12; // 83.3ms between shots (12 balls/sec)

            for (let i = 0; i < numShots; i++) {
                const dropInfo = calculateRPMDropAfterShot(config, currentRPM, ballEnergy);

                // Recovery time to get back to target RPM
                const recoveryTime = calculateSpinUpTime(config, dropInfo.finalRPM, mainRPM);

                // If recovery time > shot interval, we shoot at reduced RPM
                let actualRecovery = Math.min(recoveryTime, shotInterval);
                let rpmAtNextShot = dropInfo.finalRPM;

                if (recoveryTime <= shotInterval) {
                    rpmAtNextShot = mainRPM; // Full recovery
                } else {
                    // Partial recovery
                    const partialOmegaGain = (mainRPM - dropInfo.finalRPM) * (shotInterval / recoveryTime);
                    rpmAtNextShot = dropInfo.finalRPM + partialOmegaGain;
                }

                results.push({
                    shotNum: i + 1,
                    rpmBeforeShot: Math.round(currentRPM),
                    rpmAfterShot: Math.round(dropInfo.finalRPM),
                    rpmDrop: Math.round(dropInfo.rpmDrop),
                    recoveryTime: recoveryTime * 1000, // in ms
                    fullRecovery: recoveryTime <= shotInterval
                });

                currentRPM = rpmAtNextShot;
                totalTime += shotInterval;
            }

            // Calculate average and final stats
            const avgRPMDrop = results.reduce((sum, r) => sum + r.rpmDrop, 0) / numShots;
            const minRPM = Math.min(...results.map(r => r.rpmAfterShot));

            return {
                shots: results,
                avgRPMDrop: Math.round(avgRPMDrop),
                minRPM: Math.round(minRPM),
                totalTime: totalTime * 1000, // in ms
                finalRPM: Math.round(currentRPM)
            };
        }

        function calculateTrajectory(config, exitVelocity, spin) {
            const timeStep = 0.005;
            const maxTime = 5.0;
            const includeAirDrag = config.includeAirDrag !== false; // Default to true

            // Convert launch height from inches to meters
            const launchHeightM = config.launchHeight * 0.0254;

            // Angle conversion: 0° = vertical, positive = tilted forward
            const angleFromHorizontal = 90 - config.angle;
            const angleRad = angleFromHorizontal * Math.PI / 180;

            let vx = exitVelocity * Math.cos(angleRad);
            let vy = exitVelocity * Math.sin(angleRad);

            let x = 0;
            let y = launchHeightM;

            const ballArea = Math.PI * BALL_RADIUS_M * BALL_RADIUS_M;
            const dragCoeff = 0.47;
            const magnusCoeff = 0.25;

            const positions = [{ x: x, y: y, t: 0 }];
            let currentSpin = spin;

            let t = 0;
            while (t < maxTime && y >= 0) {
                const v = Math.sqrt(vx * vx + vy * vy);

                let dragAx = 0, dragAy = 0, magnusAx = 0, magnusAy = 0;

                if (includeAirDrag && v > 0) {
                    const drag = 0.5 * AIR_DENSITY * v * v * dragCoeff * ballArea;
                    dragAx = -drag * (vx / v) / BALL_WEIGHT_KG;
                    dragAy = -drag * (vy / v) / BALL_WEIGHT_KG;

                    const magnus = magnusCoeff * AIR_DENSITY * BALL_RADIUS_M * Math.abs(currentSpin) * v * ballArea;
                    if (currentSpin > 0) {
                        magnusAx = -magnus * (-vy / v) / BALL_WEIGHT_KG;
                        magnusAy = magnus * (vx / v) / BALL_WEIGHT_KG;
                    } else {
                        magnusAx = magnus * (-vy / v) / BALL_WEIGHT_KG;
                        magnusAy = -magnus * (vx / v) / BALL_WEIGHT_KG;
                    }
                }

                const ax = dragAx + magnusAx;
                const ay = -GRAVITY + dragAy + magnusAy;

                vx += ax * timeStep;
                vy += ay * timeStep;

                x += vx * timeStep;
                y += vy * timeStep;
                t += timeStep;

                positions.push({ x: x, y: y, t: t });

                t += timeStep;
                currentSpin *= 0.999;
            }

            return positions;
        }

        function drawTrajectory(config, trajectory) {
            const padding = 40;
            const width = canvas.width - padding * 2;
            const height = canvas.height - padding * 2;

            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Find bounds (convert everything to inches for display)
            const goalDistanceM = config.goalDistance * 0.0254;
            const goalBottomM = config.goalBottomHeight * 0.0254;
            const goalTopM = (config.goalBottomHeight + config.goalSize) * 0.0254;

            let maxX = Math.max(...trajectory.map(p => p.x), goalDistanceM * 1.2);
            let maxY = Math.max(...trajectory.map(p => p.y), goalTopM * 1.2);

            // Include overlay trajectories in bounds calculation
            if (typeof overlayTrajectories !== 'undefined' && overlayTrajectories.length > 0) {
                overlayTrajectories.forEach(overlay => {
                    maxX = Math.max(maxX, ...overlay.trajectory.map(p => p.x));
                    maxY = Math.max(maxY, ...overlay.trajectory.map(p => p.y));
                });
            }

            // Ensure minimum view
            maxX = Math.max(maxX, 5);  // At least 5 meters (~16 ft)
            maxY = Math.max(maxY, 4);  // At least 4 meters (~13 ft)

            const scaleX = width / maxX;
            const scaleY = height / maxY;
            const scale = Math.min(scaleX, scaleY);

            function toCanvasX(m) { return padding + m * scale; }
            function toCanvasY(m) { return canvas.height - padding - m * scale; }

            // Draw overlay trajectories first (behind main trajectory)
            if (typeof overlayTrajectories !== 'undefined' && overlayTrajectories.length > 0) {
                overlayTrajectories.forEach(overlay => {
                    ctx.strokeStyle = overlay.color;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]); // Dashed line for overlays
                    ctx.beginPath();

                    let started = false;
                    for (const p of overlay.trajectory) {
                        if (p.y < 0) break;
                        const cx = toCanvasX(p.x);
                        const cy = toCanvasY(p.y);

                        if (!started) {
                            ctx.moveTo(cx, cy);
                            started = true;
                        } else {
                            ctx.lineTo(cx, cy);
                        }
                    }
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset to solid

                    // Draw label at peak
                    let peakY = 0;
                    let peakX = 0;
                    for (const p of overlay.trajectory) {
                        if (p.y > peakY) {
                            peakY = p.y;
                            peakX = p.x;
                        }
                    }
                    ctx.fillStyle = overlay.color;
                    ctx.font = '11px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(overlay.name, toCanvasX(peakX), toCanvasY(peakY) - 8);
                });
            }

            // Draw grid
            ctx.strokeStyle = 'rgba(89, 0, 0, 0.25)';
            ctx.lineWidth = 1;

            // Vertical grid lines (every foot)
            for (let ft = 0; ft <= maxX * 3.281; ft += 2) {
                const x = toCanvasX(ft / 3.281);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, canvas.height - padding);
                ctx.stroke();
            }

            // Horizontal grid lines (every foot)
            for (let ft = 0; ft <= maxY * 3.281; ft += 2) {
                const y = toCanvasY(ft / 3.281);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width - padding, y);
                ctx.stroke();
            }

            // Draw ground
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(padding, toCanvasY(0));
            ctx.lineTo(canvas.width - padding, toCanvasY(0));
            ctx.stroke();

            // Draw goal
            const goalX = toCanvasX(goalDistanceM);
            const goalBottom = toCanvasY(goalBottomM);
            const goalTop = toCanvasY(goalTopM);

            // Convert goal width from inches to canvas pixels
            const goalWidthM = (config.goalWidth || 48) * 0.0254;
            const goalHalfWidthPx = Math.max(10, (goalWidthM / 2) * scale);

            // Goal structure - Open top funnel/basket design
            // Two vertical walls, open at top where balls drop in
            ctx.strokeStyle = '#8B0000';
            ctx.lineWidth = 6;

            // Left wall (from ground up to top)
            ctx.beginPath();
            ctx.moveTo(goalX - goalHalfWidthPx, toCanvasY(0));
            ctx.lineTo(goalX - goalHalfWidthPx, goalTop);
            ctx.stroke();

            // Right wall (from ground up to top)
            ctx.beginPath();
            ctx.moveTo(goalX + goalHalfWidthPx, toCanvasY(0));
            ctx.lineTo(goalX + goalHalfWidthPx, goalTop);
            ctx.stroke();

            // Bottom of goal (the floor/funnel bottom)
            ctx.beginPath();
            ctx.moveTo(goalX - goalHalfWidthPx, goalBottom);
            ctx.lineTo(goalX + goalHalfWidthPx, goalBottom);
            ctx.stroke();

            // Top opening (highlighted green) - this is where balls enter from above
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(goalX - goalHalfWidthPx, goalTop);
            ctx.lineTo(goalX + goalHalfWidthPx, goalTop);
            ctx.stroke();

            // Draw green arrows pointing down to show this is the entry
            ctx.fillStyle = '#00ff88';
            ctx.beginPath();
            ctx.moveTo(goalX, goalTop + 15);
            ctx.lineTo(goalX - 10, goalTop + 5);
            ctx.lineTo(goalX + 10, goalTop + 5);
            ctx.closePath();
            ctx.fill();

            // Goal interior fill (the funnel area)
            ctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
            ctx.fillRect(goalX - goalHalfWidthPx, goalTop, goalHalfWidthPx * 2, goalBottom - goalTop);

            // Draw shooter
            const launchHeightM = config.launchHeight * 0.0254;
            const shooterX = toCanvasX(0);
            const shooterY = toCanvasY(launchHeightM);

            ctx.fillStyle = '#666';
            ctx.fillRect(shooterX - 15, toCanvasY(0), 30, toCanvasY(0) - shooterY);

            // Draw launch angle indicator
            const angleRad = (90 - config.angle) * Math.PI / 180;
            const arrowLen = 40;
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(shooterX, shooterY);
            ctx.lineTo(shooterX + arrowLen * Math.cos(angleRad), shooterY - arrowLen * Math.sin(angleRad));
            ctx.stroke();

            // Goal collision detection - OPEN TOP FUNNEL DESIGN
            // Ball must drop INTO the goal from above through the top opening
            // Side walls block the ball from entering from the side
            const goalLeftM = goalDistanceM - goalWidthM / 2;
            const goalRightM = goalDistanceM + goalWidthM / 2;

            // Find collision point with goal structure
            let collisionPoint = null;
            let collisionType = null;
            let scoredThrough = false;

            for (let i = 1; i < trajectory.length; i++) {
                const prev = trajectory[i - 1];
                const curr = trajectory[i];

                if (curr.y < 0) break; // Hit ground

                // Check if ball is descending through the TOP OPENING (scoring)
                // Ball must be within the goal width (x between goalLeftM and goalRightM)
                // and descending through goalTopM
                if (curr.x >= goalLeftM && curr.x <= goalRightM) {
                    // Ball is horizontally over the goal
                    if (prev.y > goalTopM && curr.y <= goalTopM) {
                        // Ball is descending through the top opening - SCORE!
                        const t = (goalTopM - prev.y) / (curr.y - prev.y);
                        const crossX = prev.x + t * (curr.x - prev.x);
                        scoredThrough = true;
                        collisionPoint = { x: crossX, y: goalTopM };
                        collisionType = 'scored';
                        break;
                    }
                }

                // Check if ball hits LEFT WALL (approaching from left, below top opening)
                if (prev.x < goalLeftM && curr.x >= goalLeftM) {
                    const t = (goalLeftM - prev.x) / (curr.x - prev.x);
                    const crossY = prev.y + t * (curr.y - prev.y);

                    // If crossing below the top opening, it hits the wall
                    if (crossY <= goalTopM) {
                        collisionPoint = { x: goalLeftM, y: crossY };
                        collisionType = 'hit_wall';
                        break;
                    }
                    // If crossing above the top, ball passes over (continues trajectory)
                }

                // Check if ball hits RIGHT WALL (if ball somehow approaches from right)
                if (prev.x > goalRightM && curr.x <= goalRightM) {
                    const t = (goalRightM - prev.x) / (curr.x - prev.x);
                    const crossY = prev.y + t * (curr.y - prev.y);

                    if (crossY <= goalTopM) {
                        collisionPoint = { x: goalRightM, y: crossY };
                        collisionType = 'hit_wall';
                        break;
                    }
                }

                // Check if ball hits the BOTTOM of the funnel (after entering from top)
                if (scoredThrough && curr.y <= goalBottomM) {
                    collisionPoint = { x: curr.x, y: goalBottomM };
                    collisionType = 'scored_bottom';
                    break;
                }
            }

            // Draw trajectory (stop at collision or ground)
            ctx.strokeStyle = '#cc3333';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(toCanvasX(trajectory[0].x), toCanvasY(trajectory[0].y));

            for (let i = 1; i < trajectory.length; i++) {
                const p = trajectory[i];

                // Stop at ground
                if (p.y < 0) break;

                // Stop at collision point (blocked or scored)
                if (collisionPoint) {
                    // For collisions, stop when reaching the collision x position
                    if (p.x >= collisionPoint.x) {
                        ctx.lineTo(toCanvasX(collisionPoint.x), toCanvasY(collisionPoint.y));
                        break;
                    }
                }

                ctx.lineTo(toCanvasX(p.x), toCanvasY(p.y));
            }
            ctx.stroke();

            // Draw ball positions (stop at collision)
            const ballRadiusCanvas = BALL_RADIUS_M * scale;
            const interval = Math.max(1, Math.floor(trajectory.length / 20));

            for (let i = 0; i < trajectory.length; i += interval) {
                const p = trajectory[i];
                if (p.y < 0) break;

                // Stop drawing ball positions at collision point
                if (collisionPoint && p.x >= collisionPoint.x) break;

                ctx.strokeStyle = 'rgba(200, 80, 80, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(toCanvasX(p.x), toCanvasY(p.y),
                        Math.max(ballRadiusCanvas, 5), 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw one final ball at the collision/stop point
            if (collisionPoint) {
                const stopColor = scoredThrough ? 'rgba(0, 255, 136, 0.8)' : 'rgba(255, 68, 68, 0.8)';
                ctx.fillStyle = stopColor;
                ctx.strokeStyle = scoredThrough ? '#00ff88' : '#ff4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(toCanvasX(collisionPoint.x), toCanvasY(collisionPoint.y),
                        Math.max(ballRadiusCanvas, 8), 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }

            // Draw collision indicator
            if (collisionPoint && collisionType === 'hit_wall') {
                // Draw red X at collision point for blocked shots
                const cx = toCanvasX(collisionPoint.x);
                const cy = toCanvasY(collisionPoint.y);
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(cx - 12, cy - 12);
                ctx.lineTo(cx + 12, cy + 12);
                ctx.moveTo(cx + 12, cy - 12);
                ctx.lineTo(cx - 12, cy + 12);
                ctx.stroke();

                // Draw "BLOCKED" text
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('HIT WALL', cx, cy - 20);
            } else if (scoredThrough && collisionPoint) {
                // Draw green checkmark and "SCORE!" for successful shots
                const cx = toCanvasX(collisionPoint.x);
                const cy = toCanvasY(collisionPoint.y);
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(cx - 8, cy);
                ctx.lineTo(cx - 2, cy + 8);
                ctx.lineTo(cx + 10, cy - 8);
                ctx.stroke();

                // Draw "SCORE!" text
                ctx.fillStyle = '#00ff88';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('SCORE!', cx, cy - 25);
            }

            // Draw launch point
            ctx.fillStyle = '#00ff88';
            ctx.beginPath();
            ctx.arc(shooterX, shooterY, 8, 0, Math.PI * 2);
            ctx.fill();

            // Find and draw apex
            let maxYPos = trajectory[0];
            for (const p of trajectory) {
                if (p.y > maxYPos.y) maxYPos = p;
            }
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.moveTo(toCanvasX(maxYPos.x), toCanvasY(maxYPos.y) - 10);
            ctx.lineTo(toCanvasX(maxYPos.x) - 8, toCanvasY(maxYPos.y) + 5);
            ctx.lineTo(toCanvasX(maxYPos.x) + 8, toCanvasY(maxYPos.y) + 5);
            ctx.closePath();
            ctx.fill();

            // Draw axis labels
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';

            // X-axis labels (feet)
            for (let ft = 0; ft <= maxX * 3.281; ft += 5) {
                const x = toCanvasX(ft / 3.281);
                ctx.fillText(ft + ' ft', x, canvas.height - 10);
            }

            // Y-axis labels (feet)
            ctx.textAlign = 'right';
            for (let ft = 0; ft <= maxY * 3.281; ft += 5) {
                const y = toCanvasY(ft / 3.281);
                ctx.fillText(ft + ' ft', padding - 5, y + 4);
            }

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Ball Trajectory (side view)', padding, 25);

            return { goalDistanceM, goalBottomM, goalTopM, trajectory, collisionPoint, collisionType, scoredThrough };
        }

        function findHeightAtDistance(trajectory, targetDistanceM) {
            for (let i = 1; i < trajectory.length; i++) {
                if (trajectory[i].x >= targetDistanceM) {
                    // Linear interpolation
                    const t = (targetDistanceM - trajectory[i-1].x) / (trajectory[i].x - trajectory[i-1].x);
                    return trajectory[i-1].y + t * (trajectory[i].y - trajectory[i-1].y);
                }
            }
            return null;  // Didn't reach the distance
        }

        // Auto Power Mode: Find voltage needed to hit goal center
        function solveForVoltage(baseConfig) {
            const goalDistanceM = baseConfig.goalDistance * 0.0254;
            const goalCenterM = (baseConfig.goalBottomHeight + baseConfig.goalSize / 2) * 0.0254;

            // Helper function: calculate height at goal for a given voltage
            function getHeightAtGoalForVoltage(voltage) {
                const testConfig = Object.assign({}, baseConfig);
                testConfig.mainVoltage = voltage;
                if (testConfig.motorSetup === 'dual') {
                    // Scale back voltage proportionally
                    const ratio = baseConfig.backVoltage / baseConfig.mainVoltage || 1;
                    testConfig.backVoltage = voltage * ratio;
                } else {
                    testConfig.backVoltage = voltage;
                }

                // Recalculate gear ratios (they depend on UI values, not voltage)
                const ratioType = testConfig.ratioType;
                const isPulley = ratioType === 'pulley';

                if (isPulley) {
                    testConfig.mainGearRatio = testConfig.mainMotorPulleyTeeth / testConfig.mainWheelPulleyTeeth;
                } else {
                    testConfig.mainGearRatio = 1 / parseFloat(document.getElementById('mainGearRatioInput').value);
                }

                if (testConfig.motorSetup === 'dual') {
                    if (isPulley) {
                        testConfig.backGearRatio = testConfig.backMotorPulleyTeeth / testConfig.backWheelPulleyTeeth;
                    } else {
                        testConfig.backGearRatio = 1 / parseFloat(document.getElementById('backGearRatioInput').value);
                    }
                } else {
                    if (isPulley) {
                        testConfig.mainToBackRatio = testConfig.backPulleyMainTeeth / testConfig.backPulleyBackTeeth;
                    } else {
                        testConfig.mainToBackRatio = 1 / parseFloat(document.getElementById('backGearRatioFromMainInput').value);
                    }
                }

                // Calculate trajectory
                const mainRPM = calculateMainWheelRPM(testConfig);
                const backRPM = calculateBackWheelRPM(testConfig);
                const mainSpeed = calculateSurfaceSpeed(testConfig.mainWheelDia, mainRPM);
                const backSpeed = calculateSurfaceSpeed(testConfig.backWheelDia, backRPM);
                const exitVelocity = calculateExitVelocity(testConfig, mainSpeed, backSpeed);
                const spin = calculateBallSpin(testConfig, mainSpeed, backSpeed);
                const trajectory = calculateTrajectory(testConfig, exitVelocity, spin);

                return findHeightAtDistance(trajectory, goalDistanceM);
            }

            // First check if max voltage (12V) can even reach the goal
            const maxVoltage = 12.0;
            const minVoltage = 0.5;
            const heightAtMax = getHeightAtGoalForVoltage(maxVoltage);

            if (heightAtMax === null) {
                // Can't even reach the goal distance at max power
                return {
                    success: false,
                    reason: 'unreachable',
                    message: 'Cannot reach goal distance even at 12V. Increase angle or wheel speed ratio.',
                    voltage: null
                };
            }

            if (heightAtMax < goalCenterM) {
                // Reaches the distance but too low
                return {
                    success: false,
                    reason: 'too_low',
                    message: 'Ball too low at 12V. Height: ' + (heightAtMax * 39.37).toFixed(1) + '" vs goal center: ' + (goalCenterM * 39.37).toFixed(1) + '"',
                    voltage: 12.0,
                    heightAtGoal: heightAtMax
                };
            }

            // Binary search for the right voltage
            let low = minVoltage;
            let high = maxVoltage;
            let bestVoltage = maxVoltage;
            const tolerance = 0.01; // 1cm tolerance

            for (let iter = 0; iter < 30; iter++) {
                const mid = (low + high) / 2;
                const heightAtMid = getHeightAtGoalForVoltage(mid);

                if (heightAtMid === null) {
                    // Too low voltage, ball doesn't reach
                    low = mid;
                    continue;
                }

                const error = heightAtMid - goalCenterM;

                if (Math.abs(error) < tolerance) {
                    bestVoltage = mid;
                    break;
                }

                if (error > 0) {
                    // Ball too high, reduce voltage
                    high = mid;
                    bestVoltage = mid;
                } else {
                    // Ball too low, increase voltage
                    low = mid;
                }
            }

            // Clamp to reasonable range
            bestVoltage = Math.max(0.5, Math.min(12.0, bestVoltage));

            // Verify the result
            const finalHeight = getHeightAtGoalForVoltage(bestVoltage);
            const finalError = finalHeight ? Math.abs(finalHeight - goalCenterM) : Infinity;

            if (finalHeight === null || finalError > 0.1) {
                return {
                    success: false,
                    reason: 'no_solution',
                    message: 'Could not find voltage to hit goal center. Try adjusting angle.',
                    voltage: bestVoltage,
                    heightAtGoal: finalHeight
                };
            }

            return {
                success: true,
                voltage: bestVoltage,
                heightAtGoal: finalHeight,
                goalCenter: goalCenterM,
                message: 'Voltage: ' + bestVoltage.toFixed(2) + 'V will hit goal center'
            };
        }

        function calculate() {
            const config = getConfig();

            // Auto Power Mode: Solve for voltage to hit goal center
            const autoPowerMode = document.getElementById('autoPowerMode').checked;
            const autoPowerStatus = document.getElementById('autoPowerStatus');
            const autoPowerResult = document.getElementById('autoPowerResult');

            if (autoPowerMode) {
                const solution = solveForVoltage(config);

                if (solution.success) {
                    // Apply the solved voltage
                    config.mainVoltage = solution.voltage;
                    if (config.motorSetup === 'dual') {
                        const ratio = parseFloat(document.getElementById('backVoltageInput').value) /
                                     parseFloat(document.getElementById('mainVoltageInput').value) || 1;
                        config.backVoltage = solution.voltage * ratio;
                    } else {
                        config.backVoltage = solution.voltage;
                    }

                    // Update UI to show calculated voltage
                    document.getElementById('mainVoltageInput').value = solution.voltage.toFixed(2);
                    document.getElementById('mainVoltageSlider').value = solution.voltage.toFixed(2);
                    if (config.motorSetup === 'dual') {
                        document.getElementById('backVoltageInput').value = config.backVoltage.toFixed(2);
                        document.getElementById('backVoltageSlider').value = config.backVoltage.toFixed(2);
                    }

                    autoPowerResult.innerHTML =
                        '<span style="color: #00ff88;">✓ AUTO POWER: ' + solution.voltage.toFixed(2) + 'V</span><br>' +
                        '<small>Ball will hit goal center at ' + (solution.heightAtGoal * 39.37).toFixed(1) + '"</small>';
                    autoPowerStatus.style.borderColor = 'rgba(0, 255, 136, 0.5)';
                } else {
                    // Show warning
                    autoPowerResult.innerHTML =
                        '<span style="color: #ff4444;">⚠ WARNING: ' + solution.reason.toUpperCase() + '</span><br>' +
                        '<small>' + solution.message + '</small>';
                    autoPowerStatus.style.borderColor = 'rgba(255, 68, 68, 0.5)';

                    // Use max voltage anyway so user can see the trajectory
                    if (solution.voltage) {
                        config.mainVoltage = solution.voltage;
                        config.backVoltage = solution.voltage;
                        document.getElementById('mainVoltageInput').value = solution.voltage.toFixed(2);
                        document.getElementById('mainVoltageSlider').value = solution.voltage.toFixed(2);
                    }
                }
            }

            // Calculate motor and wheel speeds
            const mainMotorRPM = calculateMainMotorRPM(config);
            const backMotorRPM = calculateBackMotorRPM(config);
            const mainRPM = calculateMainWheelRPM(config);
            const backRPM = calculateBackWheelRPM(config);

            const mainSpeed = calculateSurfaceSpeed(config.mainWheelDia, mainRPM);
            const backSpeed = calculateSurfaceSpeed(config.backWheelDia, backRPM);

            const speedDiff = mainSpeed.inPerSec - backSpeed.inPerSec;

            const exitVelocity = calculateExitVelocity(config, mainSpeed, backSpeed);
            const spin = calculateBallSpin(config, mainSpeed, backSpeed);

            // Calculate trajectory
            const trajectory = calculateTrajectory(config, exitVelocity, spin);

            // Find max height and distance
            let maxHeight = 0;
            let maxDistance = 0;
            for (const p of trajectory) {
                if (p.y > maxHeight) maxHeight = p.y;
                if (p.x > maxDistance && p.y >= 0) maxDistance = p.x;
            }

            // Draw
            const drawResult = drawTrajectory(config, trajectory);

            // Check goal status using collision detection from draw
            const goalDistanceM = config.goalDistance * 0.0254;
            const heightAtGoal = findHeightAtDistance(trajectory, goalDistanceM);
            const goalBottomM = config.goalBottomHeight * 0.0254;
            const goalTopM = (config.goalBottomHeight + config.goalSize) * 0.0254;

            let goalStatus = '';
            let statusClass = '';

            // Use collision detection results from drawTrajectory
            if (drawResult.scoredThrough) {
                goalStatus = 'SCORE! Ball drops into goal';
                statusClass = 'success';
            } else if (drawResult.collisionType === 'hit_wall') {
                goalStatus = 'BLOCKED - Hits goal wall (ball too low)';
                statusClass = 'error';
            } else if (heightAtGoal === null) {
                goalStatus = 'SHORT - Ball lands before reaching goal';
                statusClass = 'error';
            } else if (heightAtGoal < goalTopM) {
                goalStatus = 'TOO LOW - Ball below rim, will hit wall';
                statusClass = 'error';
            } else {
                // Ball is above the rim at goal distance - check if it descends into goal
                goalStatus = 'PASSING OVER - Ball clears the goal';
                statusClass = 'warning';
            }

            // Update results display
            const mainMotorName = MOTORS[config.mainMotorType].name;
            const backMotorName = MOTORS[config.backMotorType].name;

            if (config.motorSetup === 'dual') {
                document.getElementById('resultMotorRPM').textContent =
                    'Main: ' + Math.round(mainMotorRPM) + ' / Back: ' + Math.round(backMotorRPM);
            } else {
                document.getElementById('resultMotorRPM').textContent = Math.round(mainMotorRPM) + ' RPM';
            }

            document.getElementById('resultMainRPM').textContent = Math.round(mainRPM) + ' RPM';
            document.getElementById('resultMainSpeed').textContent = mainSpeed.inPerSec.toFixed(0) + ' in/s';
            document.getElementById('resultBackSpeed').textContent = backSpeed.inPerSec.toFixed(0) + ' in/s';

            // Speed difference with drag explanation
            let spinType = '';
            if (speedDiff > 10) {
                spinType = '(BACKSPIN - lifts ball)';
            } else if (speedDiff < -10) {
                spinType = '(TOPSPIN - drops ball)';
            } else {
                spinType = '(minimal spin)';
            }
            document.getElementById('resultSpeedDiff').textContent =
                (speedDiff > 0 ? '+' : '') + speedDiff.toFixed(0) + ' in/s ' + spinType;

            document.getElementById('resultExitVel').textContent =
                exitVelocity.toFixed(1) + ' m/s (' + (exitVelocity * 3.281).toFixed(1) + ' ft/s)';
            document.getElementById('resultSpin').textContent =
                Math.round(spin * 60 / (2 * Math.PI)) + ' RPM';
            document.getElementById('resultMaxHeight').textContent =
                (maxHeight * 39.37).toFixed(1) + '" (' + (maxHeight * 3.281).toFixed(1) + ' ft)';
            document.getElementById('resultMaxDist').textContent =
                (maxDistance * 39.37).toFixed(1) + '" (' + (maxDistance * 3.281).toFixed(1) + ' ft)';

            const goalStatusEl = document.getElementById('resultGoalStatus');
            goalStatusEl.innerHTML = '<span class="status-indicator ' + statusClass + '"></span>' + goalStatus;

            if (heightAtGoal !== null) {
                document.getElementById('resultHeightAtGoal').textContent =
                    (heightAtGoal * 39.37).toFixed(1) + '" (' + (heightAtGoal * 3.281).toFixed(1) + ' ft)';
            } else {
                document.getElementById('resultHeightAtGoal').textContent = 'N/A (too short)';
            }

            // Horizontal margin calculation (goal width - ball diameter)
            const goalWidth = config.goalWidth || 12;
            const horizMargin = goalWidth - BALL_DIAMETER_IN;
            const marginPerSide = horizMargin / 2;
            let marginColor = '';
            if (horizMargin < 1) {
                marginColor = 'color: #ff4444;'; // Very tight
            } else if (horizMargin < 3) {
                marginColor = 'color: #ffaa00;'; // Tight
            } else {
                marginColor = 'color: #00ff88;'; // Good margin
            }
            document.getElementById('resultHorizMargin').innerHTML =
                '<span style="' + marginColor + '">' + horizMargin.toFixed(2) + '" total (' +
                marginPerSide.toFixed(2) + '" each side)</span>';

            // Ratio display
            if (config.ratioType === 'pulley') {
                if (config.mainMotorPulleyTeeth && config.mainWheelPulleyTeeth) {
                    document.getElementById('resultMainRatio').textContent =
                        config.mainMotorPulleyTeeth + ':' + config.mainWheelPulleyTeeth +
                        ' (' + config.mainGearRatio.toFixed(2) + 'x)';
                }
                if (config.motorSetup === 'dual') {
                    if (config.backMotorPulleyTeeth && config.backWheelPulleyTeeth) {
                        document.getElementById('resultBackRatio').textContent =
                            config.backMotorPulleyTeeth + ':' + config.backWheelPulleyTeeth +
                            ' (' + config.backGearRatio.toFixed(2) + 'x)';
                    }
                } else {
                    if (config.backPulleyMainTeeth && config.backPulleyBackTeeth) {
                        document.getElementById('resultBackRatio').textContent =
                            config.backPulleyMainTeeth + ':' + config.backPulleyBackTeeth +
                            ' (' + config.mainToBackRatio.toFixed(2) + 'x)';
                    }
                }
            } else {
                document.getElementById('resultMainRatio').textContent =
                    (1/config.mainGearRatio).toFixed(2) + ':1';
                if (config.motorSetup === 'dual') {
                    document.getElementById('resultBackRatio').textContent =
                        (1/config.backGearRatio).toFixed(2) + ':1';
                } else {
                    document.getElementById('resultBackRatio').textContent =
                        config.mainToBackRatio.toFixed(2) + ':1';
                }
            }

            // Spin-up and recovery calculations
            const mainInertia = calculateMainShaftInertia(config);
            const ballEnergy = calculateBallEnergy(exitVelocity, spin);
            const rpmDropInfo = calculateRPMDropAfterShot(config, mainRPM, ballEnergy);
            const spinUpTime = calculateSpinUpTime(config, 0, mainRPM);
            const recoveryTime = calculateSpinUpTime(config, rpmDropInfo.finalRPM, mainRPM);

            // Display inertia (convert to lb*in^2 for familiarity)
            const inertiaLbIn2 = mainInertia / (0.453592 * 0.0254 * 0.0254);
            document.getElementById('resultInertia').textContent =
                inertiaLbIn2.toFixed(2) + ' lb-in^2';

            // Calculate and display total shaft weight
            const shaftWeight = (config.mainShaftLength || 0) * HEX_SHAFT_WEIGHT_PER_INCH;
            const totalWheelWeight = config.mainWheelMass * config.numMainWheels;
            const flywheelWeight = config.useFlywheels ? config.flywheelMass * config.numFlywheels : 0;
            const extraWeight = config.mainShaftExtraMass || 0;
            const totalMainShaftWeight = shaftWeight + totalWheelWeight + flywheelWeight + extraWeight;
            document.getElementById('resultShaftWeight').textContent =
                totalMainShaftWeight.toFixed(3) + ' lbs (shaft: ' + shaftWeight.toFixed(3) + ')';

            document.getElementById('resultSpinUpTime').textContent =
                (spinUpTime * 1000).toFixed(0) + ' ms';

            document.getElementById('resultBallEnergy').textContent =
                ballEnergy.toFixed(2) + ' J';

            document.getElementById('resultRPMDrop').textContent =
                Math.round(rpmDropInfo.rpmDrop) + ' RPM';

            document.getElementById('resultRecoveryTime').textContent =
                (recoveryTime * 1000).toFixed(0) + ' ms';

            document.getElementById('resultPercentLoss').textContent =
                rpmDropInfo.percentDrop.toFixed(1) + '%';

            // Multi-shot analysis
            const analysis6 = analyzeMultipleShots(config, mainRPM, ballEnergy, 6);
            const analysis20 = analyzeMultipleShots(config, mainRPM, ballEnergy, 20);

            document.getElementById('result6ShotMin').textContent =
                analysis6.minRPM + ' RPM (' + ((analysis6.minRPM / mainRPM) * 100).toFixed(0) + '%)';

            document.getElementById('result6ShotAvgDrop').textContent =
                analysis6.avgRPMDrop + ' RPM/shot';

            document.getElementById('result20ShotMin').textContent =
                analysis20.minRPM + ' RPM (' + ((analysis20.minRPM / mainRPM) * 100).toFixed(0) + '%)';

            document.getElementById('result20ShotAvgDrop').textContent =
                analysis20.avgRPMDrop + ' RPM/shot';

            // Sustained fire rating
            let sustainedRating = '';
            const minRPMPercent = (analysis20.minRPM / mainRPM) * 100;
            if (minRPMPercent >= 95) {
                sustainedRating = 'EXCELLENT - Maintains 95%+ speed';
            } else if (minRPMPercent >= 85) {
                sustainedRating = 'GOOD - Maintains 85-95% speed';
            } else if (minRPMPercent >= 70) {
                sustainedRating = 'FAIR - Drops to 70-85% speed';
            } else {
                sustainedRating = 'POOR - Significant speed loss (' + minRPMPercent.toFixed(0) + '%)';
            }
            document.getElementById('resultSustainedFire').textContent = sustainedRating;

            // Thermal analysis
            const loadPercent = 0.25; // Estimate 25% average load for shooter maintenance
            const mainThermal = calculateMotorHeatGeneration(config.mainMotorType, config.mainUseFOC, loadPercent);

            document.getElementById('resultMainHeat').textContent =
                mainThermal.heatWatts.toFixed(1) + 'W (' + (mainThermal.efficiency * 100).toFixed(0) + '% eff)';

            // Back motor heat (only in dual mode)
            if (config.motorSetup === 'dual') {
                const backThermal = calculateMotorHeatGeneration(config.backMotorType, config.backUseFOC, loadPercent * 0.5);
                document.getElementById('resultBackHeat').textContent =
                    backThermal.heatWatts.toFixed(1) + 'W (' + (backThermal.efficiency * 100).toFixed(0) + '% eff)';
            } else {
                document.getElementById('resultBackHeat').textContent = 'N/A (single motor)';
            }

            // Temperature rise over time
            const tempRise30s = calculateThermalRise(mainThermal.heatWatts, 30);
            const tempRise2min = calculateThermalRise(mainThermal.heatWatts, 120);

            document.getElementById('resultTempRise30').textContent =
                '+' + tempRise30s.toFixed(1) + '°C (' + (AMBIENT_TEMP + tempRise30s).toFixed(0) + '°C)';
            document.getElementById('resultTempRise2min').textContent =
                '+' + tempRise2min.toFixed(1) + '°C (' + (AMBIENT_TEMP + tempRise2min).toFixed(0) + '°C)';

            // RPM loss due to thermal
            const rpmLossPercent40C = calculateThermalRPMLoss(40);
            const rpmLossActual = mainRPM * (rpmLossPercent40C / 100);
            document.getElementById('resultRPMLossThermal').textContent =
                '-' + rpmLossPercent40C.toFixed(1) + '% (-' + Math.round(rpmLossActual) + ' RPM)';

            // Velocity change due to thermal RPM loss
            const velLossPercent = rpmLossPercent40C * 0.5; // Roughly half the RPM loss translates to velocity
            document.getElementById('resultVelLossThermal').textContent =
                '-' + velLossPercent.toFixed(1) + '% @ +40°C';

            // Thermal rating
            let thermalRating = '';
            const motorEfficiency = MOTORS[config.mainMotorType].maxEfficiency;
            if (tempRise2min < 30 && motorEfficiency >= 0.85) {
                thermalRating = 'EXCELLENT - X60 runs cool';
            } else if (tempRise2min < 45) {
                thermalRating = 'GOOD - Acceptable heat buildup';
            } else if (tempRise2min < 60) {
                thermalRating = 'FAIR - Monitor motor temp';
            } else {
                thermalRating = 'POOR - Risk of thermal throttling';
            }

            // Add motor comparison note
            if (config.mainMotorType === 'x44') {
                thermalRating += ' (X44: 81% eff)';
            } else {
                thermalRating += ' (X60: 87% eff)';
            }
            document.getElementById('resultThermalRating').textContent = thermalRating;

            // Update auto BPS if enabled
            if (typeof maybeUpdateAutoBPS === 'function') {
                maybeUpdateAutoBPS();
            }
        }

        // Initial setup
        updateMotorSetupVisibility();
        calculate();

        // Animation system
        let animationId = null;
        let animatedBalls = [];
        let lastSpawnTime = 0;
        let animStartTime = 0;
        let cachedTrajectory = null;
        let cachedConfig = null;

        function startAnimation() {
            if (animationId) return; // Already running

            // Cache the current trajectory and config
            cachedConfig = getConfig();

            const mainMotorRPM = calculateMainMotorRPM(cachedConfig);
            const mainRPM = calculateMainWheelRPM(cachedConfig);
            const backRPM = calculateBackWheelRPM(cachedConfig);
            const mainSpeed = calculateSurfaceSpeed(cachedConfig.mainWheelDia, mainRPM);
            const backSpeed = calculateSurfaceSpeed(cachedConfig.backWheelDia, backRPM);
            const exitVelocity = calculateExitVelocity(cachedConfig, mainSpeed, backSpeed);
            const spin = calculateBallSpin(cachedConfig, mainSpeed, backSpeed);

            cachedTrajectory = calculateTrajectory(cachedConfig, exitVelocity, spin);

            animatedBalls = [];
            lastSpawnTime = 0;
            animStartTime = performance.now();

            document.getElementById('startAnimBtn').style.display = 'none';
            document.getElementById('stopAnimBtn').style.display = 'block';

            animationLoop();
        }

        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            animatedBalls = [];
            document.getElementById('startAnimBtn').style.display = 'block';
            document.getElementById('stopAnimBtn').style.display = 'none';
            calculate(); // Redraw static view
        }

        function getPositionAtTime(trajectory, time) {
            // Find position along trajectory at given time
            for (let i = 1; i < trajectory.length; i++) {
                if (trajectory[i].t >= time) {
                    // Interpolate between points
                    const t0 = trajectory[i-1].t;
                    const t1 = trajectory[i].t;
                    const ratio = (time - t0) / (t1 - t0);
                    return {
                        x: trajectory[i-1].x + ratio * (trajectory[i].x - trajectory[i-1].x),
                        y: trajectory[i-1].y + ratio * (trajectory[i].y - trajectory[i-1].y),
                        valid: true
                    };
                }
            }
            return { x: 0, y: 0, valid: false }; // Ball has landed or past trajectory
        }

        // Calculate maximum BPS without ball clipping
        // Simulates actual ball spawning and uses same overlap detection as animation
        function calculateMaxBPSNoClipping(trajectory) {
            if (!trajectory || trajectory.length < 2) return 1;

            const ballDiameterM = BALL_DIAMETER_IN * 0.0254;
            const overlapThreshold = ballDiameterM * 0.9; // Same as animation: 90% of diameter = overlap
            const maxTime = trajectory[trajectory.length - 1].t;

            // Simulate balls at a given BPS and check for any overlap
            function simulateAndCheckOverlap(bps) {
                const spawnInterval = 1 / bps;
                const balls = [];

                // Simulate for the full trajectory duration
                for (let t = 0; t < maxTime; t += 0.01) {
                    // Spawn balls at the correct intervals
                    const numBallsToSpawn = Math.floor(t / spawnInterval) + 1;
                    while (balls.length < numBallsToSpawn) {
                        balls.push({ spawnTime: balls.length * spawnInterval });
                    }

                    // Get positions of all active balls at time t
                    const activeBalls = [];
                    for (const ball of balls) {
                        const ballTime = t - ball.spawnTime;
                        if (ballTime >= 0) {
                            const pos = getPositionAtTime(trajectory, ballTime);
                            if (pos.valid && pos.y >= 0) {
                                activeBalls.push({ x: pos.x, y: pos.y });
                            }
                        }
                    }

                    // Check for overlaps between all pairs
                    for (let i = 0; i < activeBalls.length; i++) {
                        for (let j = i + 1; j < activeBalls.length; j++) {
                            const dx = activeBalls[i].x - activeBalls[j].x;
                            const dy = activeBalls[i].y - activeBalls[j].y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < overlapThreshold) {
                                return true; // Overlap detected!
                            }
                        }
                    }
                }
                return false; // No overlap
            }

            // Start at max BPS and decrease until no overlap
            let testBPS = 20;
            const step = 0.5;

            while (testBPS > 1) {
                if (!simulateAndCheckOverlap(testBPS)) {
                    // No overlap at this BPS, we found our max
                    return testBPS;
                }
                testBPS -= step;
            }

            return 1; // Minimum BPS
        }

        // Auto-adjust BPS checkbox handler
        let isUpdatingAutoBPS = false; // Guard against infinite loops

        function updateAutoBPS() {
            if (isUpdatingAutoBPS) return;

            const checkbox = document.getElementById('autoBPSCheckbox');
            const resultDiv = document.getElementById('autoBPSResult');
            const bpsInput = document.getElementById('ballsPerSecInput');
            const bpsSlider = document.getElementById('ballsPerSecSlider');

            if (!checkbox || !checkbox.checked) {
                if (resultDiv) resultDiv.style.display = 'none';
                if (bpsInput) {
                    bpsInput.readOnly = false;
                    bpsInput.style.opacity = '1';
                }
                if (bpsSlider) {
                    bpsSlider.disabled = false;
                    bpsSlider.style.opacity = '1';
                }
                return;
            }

            isUpdatingAutoBPS = true;

            // Calculate trajectory
            const config = getConfig();
            const mainRPM = calculateMainWheelRPM(config);
            const backRPM = calculateBackWheelRPM(config);
            const mainSpeed = calculateSurfaceSpeed(config.mainWheelDia, mainRPM);
            const backSpeed = calculateSurfaceSpeed(config.backWheelDia, backRPM);
            const exitVelocity = calculateExitVelocity(config, mainSpeed, backSpeed);
            const spin = calculateBallSpin(config, mainSpeed, backSpeed);
            const trajectory = calculateTrajectory(config, exitVelocity, spin);

            // Calculate max BPS
            const maxBPS = calculateMaxBPSNoClipping(trajectory);

            // Update UI (directly, no events)
            bpsInput.value = maxBPS;
            bpsSlider.value = maxBPS;
            bpsInput.readOnly = true;
            bpsSlider.disabled = true;
            bpsInput.style.opacity = '0.7';
            bpsSlider.style.opacity = '0.7';

            resultDiv.style.display = 'block';
            resultDiv.innerHTML = 'Max BPS without clipping: <strong>' + maxBPS.toFixed(1) + '</strong>';

            isUpdatingAutoBPS = false;
        }

        // Add event listener for auto BPS checkbox
        document.getElementById('autoBPSCheckbox').addEventListener('change', updateAutoBPS);

        // Update auto BPS when trajectory parameters change (if checkbox is checked)
        function maybeUpdateAutoBPS() {
            if (document.getElementById('autoBPSCheckbox').checked) {
                updateAutoBPS();
            }
        }

        function animationLoop() {
            const now = performance.now();

            // Update config and trajectory in real-time
            cachedConfig = getConfig();
            const mainMotorRPM = calculateMainMotorRPM(cachedConfig);
            const mainRPM = calculateMainWheelRPM(cachedConfig);
            const backRPM = calculateBackWheelRPM(cachedConfig);
            const mainSpeed = calculateSurfaceSpeed(cachedConfig.mainWheelDia, mainRPM);
            const backSpeed = calculateSurfaceSpeed(cachedConfig.backWheelDia, backRPM);
            const exitVelocity = calculateExitVelocity(cachedConfig, mainSpeed, backSpeed);
            const spin = calculateBallSpin(cachedConfig, mainSpeed, backSpeed);
            cachedTrajectory = calculateTrajectory(cachedConfig, exitVelocity, spin);

            const elapsed = (now - animStartTime) / 1000 * cachedConfig.animSpeed; // seconds with speed multiplier
            const spawnInterval = 1 / cachedConfig.ballsPerSec;

            // Spawn new balls
            while (elapsed - lastSpawnTime >= spawnInterval) {
                lastSpawnTime += spawnInterval;
                animatedBalls.push({
                    spawnTime: lastSpawnTime,
                    id: Math.random()
                });
            }

            // Update ball positions and remove landed balls
            const activeBalls = [];
            for (const ball of animatedBalls) {
                const ballTime = elapsed - ball.spawnTime;
                if (ballTime >= 0) {
                    const pos = getPositionAtTime(cachedTrajectory, ballTime);
                    if (pos.valid && pos.y >= 0) {
                        activeBalls.push({
                            ...ball,
                            x: pos.x,
                            y: pos.y,
                            time: ballTime
                        });
                    }
                } else {
                    // Not yet spawned, keep it
                    activeBalls.push(ball);
                }
            }
            animatedBalls = activeBalls;

            // Limit total balls to prevent memory issues
            if (animatedBalls.length > 100) {
                animatedBalls = animatedBalls.slice(-100);
            }

            // Check for overlaps
            const ballDiameterM = BALL_DIAMETER_IN * 0.0254;
            const overlapThreshold = ballDiameterM * 0.9; // 90% of diameter = overlap

            for (let i = 0; i < animatedBalls.length; i++) {
                animatedBalls[i].overlapping = false;
                if (animatedBalls[i].x === undefined) continue;

                for (let j = 0; j < animatedBalls.length; j++) {
                    if (i === j || animatedBalls[j].x === undefined) continue;
                    const dx = animatedBalls[i].x - animatedBalls[j].x;
                    const dy = animatedBalls[i].y - animatedBalls[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < overlapThreshold) {
                        animatedBalls[i].overlapping = true;
                        animatedBalls[j].overlapping = true;
                    }
                }
            }

            // Draw
            drawAnimatedFrame();

            animationId = requestAnimationFrame(animationLoop);
        }

        function drawAnimatedFrame() {
            const config = cachedConfig;
            const trajectory = cachedTrajectory;

            const padding = 40;
            const width = canvas.width - padding * 2;
            const height = canvas.height - padding * 2;

            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Find bounds
            const goalDistanceM = config.goalDistance * 0.0254;
            const goalBottomM = config.goalBottomHeight * 0.0254;
            const goalTopM = (config.goalBottomHeight + config.goalSize) * 0.0254;

            let maxX = Math.max(...trajectory.map(p => p.x), goalDistanceM * 1.2);
            let maxY = Math.max(...trajectory.map(p => p.y), goalTopM * 1.2);

            // Include overlay trajectories in bounds calculation
            if (typeof overlayTrajectories !== 'undefined') {
                overlayTrajectories.forEach(overlay => {
                    maxX = Math.max(maxX, ...overlay.trajectory.map(p => p.x));
                    maxY = Math.max(maxY, ...overlay.trajectory.map(p => p.y));
                });
            }

            maxX = Math.max(maxX, 5);
            maxY = Math.max(maxY, 4);

            const scaleX = width / maxX;
            const scaleY = height / maxY;
            const scale = Math.min(scaleX, scaleY);

            function toCanvasX(m) { return padding + m * scale; }
            function toCanvasY(m) { return canvas.height - padding - m * scale; }

            // Draw overlay trajectories first (behind everything)
            if (typeof overlayTrajectories !== 'undefined' && overlayTrajectories.length > 0) {
                overlayTrajectories.forEach(overlay => {
                    ctx.strokeStyle = overlay.color;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]); // Dashed line for overlays
                    ctx.beginPath();

                    let started = false;
                    for (const p of overlay.trajectory) {
                        if (p.y < 0) break;
                        const cx = toCanvasX(p.x);
                        const cy = toCanvasY(p.y);

                        if (!started) {
                            ctx.moveTo(cx, cy);
                            started = true;
                        } else {
                            ctx.lineTo(cx, cy);
                        }
                    }
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset to solid

                    // Draw label at peak
                    let peakY = 0;
                    let peakX = 0;
                    for (const p of overlay.trajectory) {
                        if (p.y > peakY) {
                            peakY = p.y;
                            peakX = p.x;
                        }
                    }
                    ctx.fillStyle = overlay.color;
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(overlay.name, toCanvasX(peakX), toCanvasY(peakY) - 5);
                });
            }

            // Draw grid
            ctx.strokeStyle = 'rgba(89, 0, 0, 0.25)';
            ctx.lineWidth = 1;
            for (let ft = 0; ft <= maxX * 3.281; ft += 2) {
                const x = toCanvasX(ft / 3.281);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, canvas.height - padding);
                ctx.stroke();
            }
            for (let ft = 0; ft <= maxY * 3.281; ft += 2) {
                const y = toCanvasY(ft / 3.281);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width - padding, y);
                ctx.stroke();
            }

            // Draw ground
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(padding, toCanvasY(0));
            ctx.lineTo(canvas.width - padding, toCanvasY(0));
            ctx.stroke();

            // Draw goal
            const goalX = toCanvasX(goalDistanceM);
            const goalBottom = toCanvasY(goalBottomM);
            const goalTop = toCanvasY(goalTopM);

            // Convert goal width from inches to canvas pixels
            const goalWidthM = (config.goalWidth || 48) * 0.0254;
            const goalHalfWidthPx = Math.max(10, (goalWidthM / 2) * scale);

            // Goal interior fill (draw first so it's behind everything)
            ctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
            ctx.fillRect(goalX - goalHalfWidthPx + 3, goalTop, goalHalfWidthPx * 2 - 6, goalBottom - goalTop);

            // Goal collision bounds (in meters)
            const goalLeftM = goalDistanceM - goalWidthM / 2;
            const goalRightM = goalDistanceM + goalWidthM / 2;

            // Draw trajectory path (faded) with collision detection
            ctx.strokeStyle = 'rgba(200, 80, 80, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(toCanvasX(trajectory[0].x), toCanvasY(trajectory[0].y));

            let trajectoryCollision = null;
            for (let i = 1; i < trajectory.length; i++) {
                const prev = trajectory[i - 1];
                const curr = trajectory[i];

                if (curr.y < 0) break; // Hit ground

                // Check for wall collision (ball approaching goal below rim level)
                if (prev.x < goalLeftM && curr.x >= goalLeftM) {
                    const t = (goalLeftM - prev.x) / (curr.x - prev.x);
                    const crossY = prev.y + t * (curr.y - prev.y);
                    if (crossY <= goalTopM) {
                        // Wall hit!
                        trajectoryCollision = { x: goalLeftM, y: crossY, type: 'wall' };
                        ctx.lineTo(toCanvasX(goalLeftM), toCanvasY(crossY));
                        break;
                    }
                }

                // Check for scoring (descending through top opening)
                if (curr.x >= goalLeftM && curr.x <= goalRightM) {
                    if (prev.y > goalTopM && curr.y <= goalTopM) {
                        const t = (goalTopM - prev.y) / (curr.y - prev.y);
                        const crossX = prev.x + t * (curr.x - prev.x);
                        trajectoryCollision = { x: crossX, y: goalTopM, type: 'scored' };
                        ctx.lineTo(toCanvasX(crossX), toCanvasY(goalTopM));
                        break;
                    }
                }

                ctx.lineTo(toCanvasX(curr.x), toCanvasY(curr.y));
            }
            ctx.stroke();

            // Draw collision indicator on trajectory
            if (trajectoryCollision) {
                const cx = toCanvasX(trajectoryCollision.x);
                const cy = toCanvasY(trajectoryCollision.y);
                if (trajectoryCollision.type === 'wall') {
                    // Red X for wall hit
                    ctx.strokeStyle = '#ff6600';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(cx - 8, cy - 8);
                    ctx.lineTo(cx + 8, cy + 8);
                    ctx.moveTo(cx + 8, cy - 8);
                    ctx.lineTo(cx - 8, cy + 8);
                    ctx.stroke();
                } else if (trajectoryCollision.type === 'scored') {
                    // Green check for score
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(cx - 6, cy);
                    ctx.lineTo(cx - 2, cy + 6);
                    ctx.lineTo(cx + 8, cy - 6);
                    ctx.stroke();
                }
            }

            // Draw shooter
            const launchHeightM = config.launchHeight * 0.0254;
            const shooterX = toCanvasX(0);
            const shooterY = toCanvasY(launchHeightM);
            ctx.fillStyle = '#666';
            ctx.fillRect(shooterX - 15, toCanvasY(0), 30, toCanvasY(0) - shooterY);

            // Draw launch point
            ctx.fillStyle = '#00ff88';
            ctx.beginPath();
            ctx.arc(shooterX, shooterY, 8, 0, Math.PI * 2);
            ctx.fill();

            // Draw animated balls with wall collision detection
            const ballRadiusCanvas = Math.max(BALL_RADIUS_M * scale, 8);

            // Check if any ball is overlapping for status
            const anyOverlap = animatedBalls.some(b => b.overlapping);

            // Determine if this trajectory hits wall or scores (affects all ball colors)
            const willHitWall = trajectoryCollision && trajectoryCollision.type === 'wall';
            const willScore = trajectoryCollision && trajectoryCollision.type === 'scored';

            for (const ball of animatedBalls) {
                if (ball.x === undefined) continue;

                const cx = toCanvasX(ball.x);
                const cy = toCanvasY(ball.y);

                // Ball color based on trajectory outcome
                let ballStatus = willHitWall ? 'wall_hit' : 'good';

                // Check for overlap status (overrides trajectory color)
                if (ball.overlapping) {
                    ballStatus = 'overlap';
                }

                // Set colors based on status
                if (ballStatus === 'wall_hit') {
                    ctx.fillStyle = 'rgba(255, 100, 0, 0.9)'; // Orange for wall hit trajectory
                    ctx.strokeStyle = '#ff6600';
                } else if (ballStatus === 'overlap') {
                    ctx.fillStyle = 'rgba(255, 68, 68, 0.9)'; // Red for overlap
                    ctx.strokeStyle = '#ff0000';
                } else {
                    ctx.fillStyle = 'rgba(0, 255, 136, 0.9)'; // Green for good/scoring trajectory
                    ctx.strokeStyle = '#00ff88';
                }

                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(cx, cy, ballRadiusCanvas, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }

            // Draw goal walls ON TOP of balls (so they appear crisp)
            ctx.strokeStyle = '#8B0000';
            ctx.lineWidth = 6;

            // Left wall (from ground up to top)
            ctx.beginPath();
            ctx.moveTo(goalX - goalHalfWidthPx, toCanvasY(0));
            ctx.lineTo(goalX - goalHalfWidthPx, goalTop);
            ctx.stroke();

            // Right wall (from ground up to top)
            ctx.beginPath();
            ctx.moveTo(goalX + goalHalfWidthPx, toCanvasY(0));
            ctx.lineTo(goalX + goalHalfWidthPx, goalTop);
            ctx.stroke();

            // Bottom of goal
            ctx.beginPath();
            ctx.moveTo(goalX - goalHalfWidthPx, goalBottom);
            ctx.lineTo(goalX + goalHalfWidthPx, goalBottom);
            ctx.stroke();

            // Top opening (highlighted green)
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(goalX - goalHalfWidthPx, goalTop);
            ctx.lineTo(goalX + goalHalfWidthPx, goalTop);
            ctx.stroke();

            // Green arrow pointing down
            ctx.fillStyle = '#00ff88';
            ctx.beginPath();
            ctx.moveTo(goalX, goalTop + 15);
            ctx.lineTo(goalX - 10, goalTop + 5);
            ctx.lineTo(goalX + 10, goalTop + 5);
            ctx.closePath();
            ctx.fill();

            // Draw status
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Ball Animation - ' + cachedConfig.ballsPerSec + ' BPS', padding, 25);

            // Status indicators
            let statusText = '';
            let statusColor = '#00ff88';
            if (willHitWall) {
                statusText = 'WALL HIT - Blocked!';
                statusColor = '#ff6600';
            } else if (anyOverlap) {
                statusText = 'OVERLAP DETECTED';
                statusColor = '#ff4444';
            } else {
                statusText = 'SCORING!';
                statusColor = '#00ff88';
            }
            ctx.fillStyle = statusColor;
            ctx.fillText(statusText, padding + 200, 25);

            // Ball count
            ctx.fillStyle = '#888';
            ctx.fillText('Active balls: ' + animatedBalls.filter(b => b.x !== undefined).length, padding, 45);

            // Axis labels
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            for (let ft = 0; ft <= maxX * 3.281; ft += 5) {
                const x = toCanvasX(ft / 3.281);
                ctx.fillText(ft + ' ft', x, canvas.height - 10);
            }
            ctx.textAlign = 'right';
            for (let ft = 0; ft <= maxY * 3.281; ft += 5) {
                const y = toCanvasY(ft / 3.281);
                ctx.fillText(ft + ' ft', padding - 5, y + 4);
            }
        }

        // ====================================
        // Configuration Manager
        // ====================================

        const CONFIG_STORAGE_KEY = 'frc_shooter_configs';
        var overlayTrajectories = [];  // Using var for hoisting so it's available in drawTrajectory
        const OVERLAY_COLORS = [
            '#ff6b6b', '#ffd54f', '#c0c0c0', '#ff8a65',
            '#e57373', '#ffab91', '#fff176', '#bcaaa4'
        ];

        // Get all saveable config values
        function getFullConfig() {
            return {
                // Motor setup
                motorSetup: document.getElementById('motorSetup').value,
                ratioType: document.getElementById('ratioType').value,

                // Main motor
                mainMotorType: document.getElementById('mainMotorType').value,
                mainVoltage: document.getElementById('mainVoltageInput').value,
                mainUseFOC: document.getElementById('mainUseFOC').checked,

                // Main wheel
                mainWheelDia: document.getElementById('mainWheelDiaInput').value,
                motorPulleyTeeth: document.getElementById('motorPulleyTeethInput').value,
                mainPulleyTeeth: document.getElementById('mainPulleyTeethInput').value,
                mainGearRatio: document.getElementById('mainGearRatioInput').value,

                // Back motor (dual mode)
                backMotorType: document.getElementById('backMotorType').value,
                backVoltage: document.getElementById('backVoltageInput').value,
                backUseFOC: document.getElementById('backUseFOC').checked,

                // Back wheel
                backWheelDia: document.getElementById('backWheelDiaInput').value,
                backPulleyMainTeeth: document.getElementById('backPulleyMainTeethInput').value,
                backPulleyBackTeeth: document.getElementById('backPulleyBackTeethInput').value,
                backGearRatioFromMain: document.getElementById('backGearRatioFromMainInput').value,
                backMotorPulleyTeeth: document.getElementById('backMotorPulleyTeethInput').value,
                backWheelPulleyTeeth: document.getElementById('backWheelPulleyTeethInput').value,
                backGearRatio: document.getElementById('backGearRatioInput').value,

                // Shooter settings
                compression: document.getElementById('compressionInput').value,
                contactTime: document.getElementById('contactTimeInput').value,
                launchHeight: document.getElementById('launchHeightInput').value,
                angle: document.getElementById('angleInput').value,

                // Goal settings
                goalDistance: document.getElementById('goalDistanceInput').value,
                goalBottomHeight: document.getElementById('goalBottomHeightInput').value,
                goalSize: document.getElementById('goalSizeInput').value,
                goalWidth: document.getElementById('goalWidthInput').value,

                // Wheel mass settings
                mainWheelMass: document.getElementById('mainWheelMassInput').value,
                numMainWheels: document.getElementById('numMainWheelsInput').value,
                backWheelMass: document.getElementById('backWheelMassInput').value,
                numBackWheels: document.getElementById('numBackWheelsInput').value,

                // Flywheel settings
                useFlywheels: document.getElementById('useFlywheels').checked,
                flywheelMass: document.getElementById('flywheelMassInput').value,
                flywheelDia: document.getElementById('flywheelDiaInput').value,
                numFlywheels: document.getElementById('numFlywheelsInput').value,

                // Simulation settings
                includeAirDrag: document.getElementById('includeAirDrag').checked,
                autoPowerMode: document.getElementById('autoPowerMode').checked,
                ballsPerSec: document.getElementById('ballsPerSecInput').value,
                animSpeed: document.getElementById('animSpeedInput').value,
                systemEfficiency: document.getElementById('systemEfficiencyInput').value,
                wheelGrip: document.getElementById('wheelGripInput').value,

                // Shaft configuration
                mainShaftLength: document.getElementById('mainShaftLengthInput').value,
                mainShaftExtraMass: document.getElementById('mainShaftExtraMassInput').value,
                backShaftLength: document.getElementById('backShaftLengthInput').value,
                backShaftExtraMass: document.getElementById('backShaftExtraMassInput').value,
                numBackStages: document.getElementById('numBackStagesInput').value
            };
        }

        // Apply config values to controls
        function applyConfig(config) {
            // Helper function to set value for synced input/slider pairs
            function setValue(inputId, sliderId, value) {
                const input = document.getElementById(inputId);
                const slider = document.getElementById(sliderId);
                if (input && value !== undefined) {
                    input.value = value;
                    if (slider) slider.value = value;
                }
            }

            // Motor setup
            if (config.motorSetup) document.getElementById('motorSetup').value = config.motorSetup;
            if (config.ratioType) document.getElementById('ratioType').value = config.ratioType;

            // Main motor
            if (config.mainMotorType) document.getElementById('mainMotorType').value = config.mainMotorType;
            setValue('mainVoltageInput', 'mainVoltageSlider', config.mainVoltage);
            if (config.mainUseFOC !== undefined) document.getElementById('mainUseFOC').checked = config.mainUseFOC;

            // Main wheel
            setValue('mainWheelDiaInput', 'mainWheelDiaSlider', config.mainWheelDia);
            setValue('motorPulleyTeethInput', 'motorPulleyTeethSlider', config.motorPulleyTeeth);
            setValue('mainPulleyTeethInput', 'mainPulleyTeethSlider', config.mainPulleyTeeth);
            setValue('mainGearRatioInput', 'mainGearRatioSlider', config.mainGearRatio);

            // Back motor
            if (config.backMotorType) document.getElementById('backMotorType').value = config.backMotorType;
            setValue('backVoltageInput', 'backVoltageSlider', config.backVoltage);
            if (config.backUseFOC !== undefined) document.getElementById('backUseFOC').checked = config.backUseFOC;

            // Back wheel
            setValue('backWheelDiaInput', 'backWheelDiaSlider', config.backWheelDia);
            setValue('backPulleyMainTeethInput', 'backPulleyMainTeethSlider', config.backPulleyMainTeeth);
            setValue('backPulleyBackTeethInput', 'backPulleyBackTeethSlider', config.backPulleyBackTeeth);
            setValue('backGearRatioFromMainInput', 'backGearRatioFromMainSlider', config.backGearRatioFromMain);
            setValue('backMotorPulleyTeethInput', 'backMotorPulleyTeethSlider', config.backMotorPulleyTeeth);
            setValue('backWheelPulleyTeethInput', 'backWheelPulleyTeethSlider', config.backWheelPulleyTeeth);
            setValue('backGearRatioInput', 'backGearRatioSlider', config.backGearRatio);

            // Shooter settings
            setValue('compressionInput', 'compressionSlider', config.compression);
            setValue('contactTimeInput', 'contactTimeSlider', config.contactTime);
            setValue('launchHeightInput', 'launchHeightSlider', config.launchHeight);
            setValue('angleInput', 'angleSlider', config.angle);

            // Goal settings
            setValue('goalDistanceInput', 'goalDistanceSlider', config.goalDistance);
            setValue('goalBottomHeightInput', 'goalBottomHeightSlider', config.goalBottomHeight);
            setValue('goalSizeInput', 'goalSizeSlider', config.goalSize);
            setValue('goalWidthInput', 'goalWidthSlider', config.goalWidth);

            // Wheel mass
            setValue('mainWheelMassInput', 'mainWheelMassSlider', config.mainWheelMass);
            setValue('numMainWheelsInput', 'numMainWheelsSlider', config.numMainWheels);
            setValue('backWheelMassInput', 'backWheelMassSlider', config.backWheelMass);
            setValue('numBackWheelsInput', 'numBackWheelsSlider', config.numBackWheels);

            // Flywheel settings
            if (config.useFlywheels !== undefined) {
                document.getElementById('useFlywheels').checked = config.useFlywheels;
                document.getElementById('flywheelConfig').style.display = config.useFlywheels ? 'block' : 'none';
            }
            setValue('flywheelMassInput', 'flywheelMassSlider', config.flywheelMass);
            setValue('flywheelDiaInput', 'flywheelDiaSlider', config.flywheelDia);
            setValue('numFlywheelsInput', 'numFlywheelsSlider', config.numFlywheels);

            // Simulation settings
            if (config.includeAirDrag !== undefined) document.getElementById('includeAirDrag').checked = config.includeAirDrag;
            if (config.autoPowerMode !== undefined) {
                document.getElementById('autoPowerMode').checked = config.autoPowerMode;
                document.getElementById('autoPowerStatus').style.display = config.autoPowerMode ? 'block' : 'none';
                // Enable/disable voltage controls based on auto power mode
                const mainVoltageInput = document.getElementById('mainVoltageInput');
                const mainVoltageSlider = document.getElementById('mainVoltageSlider');
                const backVoltageInput = document.getElementById('backVoltageInput');
                const backVoltageSlider = document.getElementById('backVoltageSlider');
                mainVoltageInput.disabled = config.autoPowerMode;
                mainVoltageSlider.disabled = config.autoPowerMode;
                backVoltageInput.disabled = config.autoPowerMode;
                backVoltageSlider.disabled = config.autoPowerMode;
                mainVoltageInput.style.opacity = config.autoPowerMode ? '0.5' : '1';
                mainVoltageSlider.style.opacity = config.autoPowerMode ? '0.5' : '1';
                backVoltageInput.style.opacity = config.autoPowerMode ? '0.5' : '1';
                backVoltageSlider.style.opacity = config.autoPowerMode ? '0.5' : '1';
            }
            setValue('ballsPerSecInput', 'ballsPerSecSlider', config.ballsPerSec);
            setValue('animSpeedInput', 'animSpeedSlider', config.animSpeed);
            setValue('systemEfficiencyInput', 'systemEfficiencySlider', config.systemEfficiency);
            setValue('wheelGripInput', 'wheelGripSlider', config.wheelGrip || 0.95);

            // Shaft configuration
            setValue('mainShaftLengthInput', 'mainShaftLengthSlider', config.mainShaftLength);
            setValue('mainShaftExtraMassInput', 'mainShaftExtraMassSlider', config.mainShaftExtraMass);
            setValue('backShaftLengthInput', 'backShaftLengthSlider', config.backShaftLength);
            setValue('backShaftExtraMassInput', 'backShaftExtraMassSlider', config.backShaftExtraMass);
            setValue('numBackStagesInput', 'numBackStagesSlider', config.numBackStages);

            // Update visibility and recalculate
            updateMotorSetupVisibility();
        }

        // Load saved configs from localStorage
        function loadSavedConfigs() {
            try {
                const saved = localStorage.getItem(CONFIG_STORAGE_KEY);
                return saved ? JSON.parse(saved) : {};
            } catch (e) {
                console.error('Error loading configs:', e);
                return {};
            }
        }

        // Save configs to localStorage
        function saveConfigsToStorage(configs) {
            try {
                localStorage.setItem(CONFIG_STORAGE_KEY, JSON.stringify(configs));
            } catch (e) {
                console.error('Error saving configs:', e);
                alert('Error saving configuration. Storage may be full.');
            }
        }

        // Update dropdown with saved configs
        function updateConfigDropdown() {
            const dropdown = document.getElementById('savedConfigsDropdown');
            const configs = loadSavedConfigs();

            // Clear existing options (except first)
            while (dropdown.options.length > 1) {
                dropdown.remove(1);
            }

            // Add saved configs
            Object.keys(configs).sort().forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                dropdown.appendChild(option);
            });
        }

        // Update overlays list display
        function updateOverlaysList() {
            const listDiv = document.getElementById('overlaysList');
            if (overlayTrajectories.length === 0) {
                listDiv.innerHTML = '<em style="color: #888;">No overlays</em>';
            } else {
                let html = '<strong style="color: #cc3333;">Overlays:</strong>';
                overlayTrajectories.forEach((o, i) => {
                    html += '<div style="display: flex; align-items: center; justify-content: space-between; margin: 4px 0; padding: 4px 6px; background: rgba(0,0,0,0.2); border-radius: 4px; border-left: 3px solid ' + o.color + ';">';
                    html += '<span><span style="color:' + o.color + ';">●</span> ' + o.name + '</span>';
                    html += '<button onclick="removeOverlay(' + i + ')" style="padding: 2px 8px; background: #590000; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8em;">×</button>';
                    html += '</div>';
                });
                listDiv.innerHTML = html;
            }
        }

        // Remove individual overlay
        function removeOverlay(index) {
            if (index >= 0 && index < overlayTrajectories.length) {
                overlayTrajectories.splice(index, 1);
                updateOverlaysList();
                calculate();
            }
        }

        // Save current config
        document.getElementById('saveConfigBtn').addEventListener('click', function() {
            const name = document.getElementById('configName').value.trim();
            if (!name) {
                alert('Please enter a config name');
                return;
            }

            const configs = loadSavedConfigs();
            if (configs[name] && !confirm('Config "' + name + '" already exists. Overwrite?')) {
                return;
            }

            configs[name] = getFullConfig();
            saveConfigsToStorage(configs);
            updateConfigDropdown();
            document.getElementById('savedConfigsDropdown').value = name;
            alert('Configuration "' + name + '" saved!');
        });

        // Load selected config
        document.getElementById('loadConfigBtn').addEventListener('click', function() {
            const name = document.getElementById('savedConfigsDropdown').value;
            if (!name) {
                alert('Please select a config to load');
                return;
            }

            const configs = loadSavedConfigs();
            if (!configs[name]) {
                alert('Config not found');
                return;
            }

            applyConfig(configs[name]);
            document.getElementById('configName').value = name;
        });

        // Delete selected config
        document.getElementById('deleteConfigBtn').addEventListener('click', function() {
            const name = document.getElementById('savedConfigsDropdown').value;
            if (!name) {
                alert('Please select a config to delete');
                return;
            }

            if (!confirm('Delete config "' + name + '"?')) {
                return;
            }

            const configs = loadSavedConfigs();
            delete configs[name];
            saveConfigsToStorage(configs);
            updateConfigDropdown();
            document.getElementById('configName').value = '';
        });

        // Export config to file
        document.getElementById('exportConfigBtn').addEventListener('click', function() {
            const name = document.getElementById('configName').value.trim() || 'shooter_config';
            const config = getFullConfig();
            config._name = name;
            config._exportDate = new Date().toISOString();

            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = name.replace(/[^a-z0-9]/gi, '_') + '.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Import config from file
        document.getElementById('importConfigBtn').addEventListener('click', function() {
            document.getElementById('importConfigFile').click();
        });

        document.getElementById('importConfigFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const config = JSON.parse(e.target.result);
                    applyConfig(config);
                    if (config._name) {
                        document.getElementById('configName').value = config._name;
                    }
                    alert('Configuration imported successfully!');
                } catch (err) {
                    alert('Error importing config: ' + err.message);
                }
            };
            reader.readAsText(file);
            this.value = ''; // Reset file input
        });

        // Add current trajectory to graph as overlay
        document.getElementById('addToGraphBtn').addEventListener('click', function() {
            const config = getConfig();
            const mainMotorRPM = calculateMainMotorRPM(config);
            const backMotorRPM = calculateBackMotorRPM(config);
            const mainRPM = calculateMainWheelRPM(config);
            const backRPM = calculateBackWheelRPM(config);
            const mainSpeed = calculateSurfaceSpeed(config.mainWheelDia, mainRPM);
            const backSpeed = calculateSurfaceSpeed(config.backWheelDia, backRPM);
            const exitVelocity = calculateExitVelocity(config, mainSpeed, backSpeed);
            const spin = calculateBallSpin(config, mainSpeed, backSpeed);
            const trajectory = calculateTrajectory(config, exitVelocity, spin);

            const name = document.getElementById('configName').value.trim() ||
                         'Config ' + (overlayTrajectories.length + 1);
            const color = OVERLAY_COLORS[overlayTrajectories.length % OVERLAY_COLORS.length];

            overlayTrajectories.push({
                name: name,
                color: color,
                trajectory: trajectory,
                exitVelocity: exitVelocity
            });

            updateOverlaysList();
            calculate(); // Redraw with overlays
        });

        // Clear all overlays
        document.getElementById('clearGraphBtn').addEventListener('click', function() {
            overlayTrajectories.length = 0;
            updateOverlaysList();
            calculate();
        });

        // Overlay drawing is now handled directly in drawTrajectory and drawAnimatedFrame
        // with proper scaling included

        // ====================================
        // Belt Calculator
        // ====================================

        const COMMON_BELT_SIZES_5M = [150, 175, 200, 225, 250, 275, 300, 325, 350, 375, 400, 425, 450, 475, 500, 525, 550, 600, 700, 800];
        const COMMON_BELT_SIZES_3M = [111, 120, 129, 138, 144, 150, 159, 168, 174, 183, 192, 201, 210, 219, 225, 240, 255, 267, 282, 294, 309, 318, 330, 345, 384, 420, 447, 486, 501];
        const COMMON_PULLEY_TEETH = [10, 12, 14, 15, 16, 18, 20, 22, 24, 26, 28, 30, 32, 36, 40, 44, 48, 60, 72];

        // Calculate pitch diameter from teeth and pitch
        function getPitchDiameter(teeth, pitchMM) {
            return (teeth * pitchMM) / Math.PI;
        }

        // Calculate belt length given pulleys and center distance
        // L = 2C + π(D1 + D2)/2 + (D1 - D2)²/(4C)
        function calculateBeltLength(teeth1, teeth2, centerDistanceMM, pitchMM) {
            const d1 = getPitchDiameter(teeth1, pitchMM);
            const d2 = getPitchDiameter(teeth2, pitchMM);
            const c = centerDistanceMM;

            const length = 2 * c + Math.PI * (d1 + d2) / 2 + Math.pow(d1 - d2, 2) / (4 * c);
            return length;
        }

        // Calculate center distance given belt length and pulleys
        // Solve: L = 2C + π(D1 + D2)/2 + (D1 - D2)²/(4C)
        // This is a quadratic in C
        function calculateCenterDistance(teeth1, teeth2, beltLengthMM, pitchMM) {
            const d1 = getPitchDiameter(teeth1, pitchMM);
            const d2 = getPitchDiameter(teeth2, pitchMM);
            const L = beltLengthMM;

            // Rearrange: 2C² - (L - π(d1+d2)/2)C + (d1-d2)²/4 = 0
            // Let b = L - π(d1+d2)/2, a = 2, c = (d1-d2)²/4
            const sumD = d1 + d2;
            const diffD = d1 - d2;
            const b = L - Math.PI * sumD / 2;
            const a = 2;
            const c = diffD * diffD / 4;

            // Quadratic formula: C = (b ± sqrt(b² - 4ac)) / 2a
            const discriminant = b * b - 4 * a * c;
            if (discriminant < 0) return null;

            const c1 = (b + Math.sqrt(discriminant)) / (2 * a);
            const c2 = (b - Math.sqrt(discriminant)) / (2 * a);

            // Return the positive, valid center distance
            // Must be greater than (d1 + d2) / 2 for pulleys not to overlap
            const minC = (d1 + d2) / 2;
            if (c1 > minC) return c1;
            if (c2 > minC) return c2;
            return null;
        }

        // Find best pulley combinations for a given belt, distance, and ratio
        // Bore type minimums: Kraken Spline = 12T, 1/2" Hex = 14T, 3/8" Hex = 10T
        const BORE_MIN_TEETH = {
            'spline': 12,   // Kraken Spline
            'hex12': 14,    // 1/2" Hex
            'hex38': 10     // 3/8" Hex
        };

        function getBoreMinTeeth(boreType) {
            return BORE_MIN_TEETH[boreType] || 12;
        }

        function findPulleyCombinations(beltLengthMM, targetDistanceMM, targetRatio, pitchMM, tolerance = 0.05, use3DPrintable = false, minDriveTeeth = null, minDrivenTeeth = null) {
            const results = [];

            // Get minimum teeth from bore type selectors if not provided
            if (minDriveTeeth === null) {
                const driveBore = document.getElementById('beltDriveBore');
                minDriveTeeth = driveBore ? getBoreMinTeeth(driveBore.value) : 12;
            }
            if (minDrivenTeeth === null) {
                const drivenBore = document.getElementById('beltDrivenBore');
                minDrivenTeeth = drivenBore ? getBoreMinTeeth(drivenBore.value) : 14;
            }

            // Use all teeth if 3D printable, otherwise just common sizes
            const driveTeethOptions = use3DPrintable
                ? Array.from({length: 72 - minDriveTeeth + 1}, (_, i) => i + minDriveTeeth)
                : COMMON_PULLEY_TEETH.filter(t => t >= minDriveTeeth);

            const drivenTeethOptions = use3DPrintable
                ? Array.from({length: 72 - minDrivenTeeth + 1}, (_, i) => i + minDrivenTeeth)
                : COMMON_PULLEY_TEETH.filter(t => t >= minDrivenTeeth);

            for (const drive of driveTeethOptions) {
                for (const driven of drivenTeethOptions) {
                    const actualRatio = driven / drive;
                    if (Math.abs(actualRatio - targetRatio) > tolerance * targetRatio) continue;

                    const calcDistance = calculateCenterDistance(drive, driven, beltLengthMM, pitchMM);
                    if (calcDistance === null) continue;

                    const distanceError = Math.abs(calcDistance - targetDistanceMM);
                    const distanceErrorPercent = (distanceError / targetDistanceMM) * 100;

                    // Mark if this uses non-standard pulley sizes
                    const isCustomDrive = !COMMON_PULLEY_TEETH.includes(drive);
                    const isCustomDriven = !COMMON_PULLEY_TEETH.includes(driven);

                    results.push({
                        drive,
                        driven,
                        ratio: actualRatio,
                        calculatedDistance: calcDistance,
                        distanceError,
                        distanceErrorPercent,
                        isCustomDrive,
                        isCustomDriven,
                        is3DPrint: isCustomDrive || isCustomDriven
                    });
                }
            }

            // Sort by distance error
            results.sort((a, b) => a.distanceError - b.distanceError);
            return results.slice(0, 5); // Top 5 results
        }

        // Toggle belt pulley optimization options
        function toggleBeltPulleyOptions(elementId, beltLengthMM, targetDistanceInches, targetRatio, pitchMM) {
            const container = document.getElementById(elementId);
            if (!container) return;

            // Toggle visibility
            if (container.style.display === 'block') {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';
            const targetDistanceMM = targetDistanceInches * 25.4;

            // Find optimal pulley combinations for this belt
            // Search both standard and 3D printable options
            const standardResults = findPulleyCombinations(beltLengthMM, targetDistanceMM, targetRatio, pitchMM, 0.15, false);
            const printableResults = findPulleyCombinations(beltLengthMM, targetDistanceMM, targetRatio, pitchMM, 0.15, true);

            // Combine and sort by distance error, removing duplicates
            const allResults = [...standardResults];
            for (const pr of printableResults) {
                if (!allResults.some(r => r.drive === pr.drive && r.driven === pr.driven)) {
                    allResults.push(pr);
                }
            }
            allResults.sort((a, b) => a.distanceError - b.distanceError);
            const topResults = allResults.slice(0, 6);

            let html = '<div style="color: #ffaa00; font-weight: bold; margin-bottom: 6px;">Optimal Pulleys for ' + beltLengthMM + 'mm belt:</div>';
            html += '<div style="color: #888; font-size: 0.85em; margin-bottom: 6px;">Target: ' + targetDistanceInches.toFixed(4) + '" | Ratio: ' + targetRatio.toFixed(3) + ':1</div>';

            if (topResults.length > 0) {
                for (const r of topResults) {
                    const isPerfect = r.distanceError < 0.5;
                    const isGood = r.distanceError < 2;
                    let bgColor = isGood ? (isPerfect ? '0,150,0' : '0,100,0') : '60,60,0';
                    const errorInches = r.distanceError / 25.4;

                    html += '<div style="margin: 3px 0; padding: 4px; background: rgba(' + bgColor + ',0.3); border-radius: 4px; font-size: 0.9em;';
                    if (r.is3DPrint) html += ' border-left: 2px solid #ffaa00;';
                    html += '">';

                    // Pulley labels with 3D print indicator
                    const driveLabel = r.isCustomDrive ? '<span style="color: #ffaa00;">' + r.drive + 'T🖨️</span>' : r.drive + 'T';
                    const drivenLabel = r.isCustomDriven ? '<span style="color: #ffaa00;">' + r.driven + 'T🖨️</span>' : r.driven + 'T';

                    html += '<strong>' + driveLabel + ' : ' + drivenLabel + '</strong>';
                    html += ' <span style="color: #888;">(ratio: ' + r.ratio.toFixed(3) + ':1)</span><br>';
                    html += '<small>C-C: ' + (r.calculatedDistance / 25.4).toFixed(4) + '" ';

                    if (isPerfect) {
                        html += '<span style="color: #00ff88; font-weight: bold;">(error: ' + errorInches.toFixed(4) + '" PERFECT!)</span>';
                    } else {
                        const errorDir = r.calculatedDistance > targetDistanceMM ? '+' : '-';
                        html += '(error: ' + errorDir + errorInches.toFixed(4) + '")';
                    }
                    html += '</small>';

                    if (r.is3DPrint) {
                        html += '<br><small style="color: #ffaa00;">🖨️ Requires 3D printed pulley</small>';
                    }
                    html += '</div>';
                }
            } else {
                html += '<div style="color: #ff4444;">No suitable pulley combinations found.</div>';
            }

            container.innerHTML = html;
        }

        // Update belt calculator UI based on mode
        document.getElementById('beltCalcMode').addEventListener('change', function() {
            const mode = this.value;
            const distanceGroup = document.getElementById('beltDistanceGroup');
            const lengthGroup = document.getElementById('beltLengthGroup');
            const ratioGroup = document.getElementById('beltRatioGroup');
            const driveGroup = document.getElementById('beltDriveGroup');
            const drivenGroup = document.getElementById('beltDrivenGroup');
            const shooterConfigSelect = document.getElementById('beltUseShooterConfig');

            if (mode === 'findBelt') {
                distanceGroup.style.display = 'block';
                lengthGroup.style.display = 'none';
                ratioGroup.style.display = 'none';
                driveGroup.style.display = 'block';
                drivenGroup.style.display = 'block';
                shooterConfigSelect.parentElement.style.display = 'block';
            } else if (mode === 'findDistance') {
                distanceGroup.style.display = 'none';
                lengthGroup.style.display = 'block';
                ratioGroup.style.display = 'none';
                driveGroup.style.display = 'block';
                drivenGroup.style.display = 'block';
                shooterConfigSelect.parentElement.style.display = 'block';
            } else if (mode === 'findPulleys') {
                distanceGroup.style.display = 'block';
                lengthGroup.style.display = 'block';
                ratioGroup.style.display = 'block';
                driveGroup.style.display = 'none';
                drivenGroup.style.display = 'none';
                shooterConfigSelect.parentElement.style.display = 'none';
                document.getElementById('belt3DPrintGroup').style.display = 'block';
            }

            // Hide 3D print option for non-findPulleys modes
            if (mode !== 'findPulleys') {
                document.getElementById('belt3DPrintGroup').style.display = 'none';
            }
        });

        // Belt calculator - Use Shooter Config dropdown
        document.getElementById('beltUseShooterConfig').addEventListener('change', function() {
            const config = this.value;
            const driveInput = document.getElementById('beltDriveTeeth');
            const drivenInput = document.getElementById('beltDrivenTeeth');
            const driveGroup = document.getElementById('beltDriveGroup');
            const drivenGroup = document.getElementById('beltDrivenGroup');
            const mode = document.getElementById('beltCalcMode').value;

            if (config === 'manual') {
                // Enable manual input
                driveInput.style.opacity = '1';
                drivenInput.style.opacity = '1';
                driveInput.readOnly = false;
                drivenInput.readOnly = false;
                driveGroup.querySelector('label').textContent = 'Drive Pulley (teeth)';
                drivenGroup.querySelector('label').textContent = 'Driven Pulley (teeth)';
            } else {
                let driveTeeth, drivenTeeth, driveLabel, drivenLabel;

                if (config === 'motor-main') {
                    // Motor → Main Wheel
                    driveTeeth = parseInt(document.getElementById('motorPulleyTeethInput').value);
                    drivenTeeth = parseInt(document.getElementById('mainPulleyTeethInput').value);
                    driveLabel = 'Motor Pulley (from config)';
                    drivenLabel = 'Main Wheel Pulley (from config)';
                } else if (config === 'main-back') {
                    // Main → Back Wheel (Single Motor mode pulleys)
                    driveTeeth = parseInt(document.getElementById('backPulleyMainTeethInput').value);
                    drivenTeeth = parseInt(document.getElementById('backPulleyBackTeethInput').value);
                    driveLabel = 'Main Side Pulley (from config)';
                    drivenLabel = 'Back Side Pulley (from config)';
                } else if (config === 'back-motor-wheel') {
                    // Back Motor → Back Wheel (Dual Motor mode)
                    driveTeeth = parseInt(document.getElementById('backMotorPulleyTeethInput').value);
                    drivenTeeth = parseInt(document.getElementById('backWheelPulleyTeethInput').value);
                    driveLabel = 'Back Motor Pulley (from config)';
                    drivenLabel = 'Back Wheel Pulley (from config)';
                }

                driveInput.value = driveTeeth;
                drivenInput.value = drivenTeeth;
                driveInput.style.opacity = '0.7';
                drivenInput.style.opacity = '0.7';
                driveInput.readOnly = true;
                drivenInput.readOnly = true;
                driveGroup.querySelector('label').textContent = driveLabel;
                drivenGroup.querySelector('label').textContent = drivenLabel;
            }

            // Hide pulley inputs if in findPulleys mode
            if (mode === 'findPulleys') {
                driveGroup.style.display = 'none';
                drivenGroup.style.display = 'none';
            }
        });

        // Update belt calculator when shooter config changes
        function updateBeltFromShooterConfig() {
            const configSelect = document.getElementById('beltUseShooterConfig');
            if (configSelect.value !== 'manual') {
                // Trigger the change event to update values
                configSelect.dispatchEvent(new Event('change'));
            }
        }

        // Listen to shooter pulley changes
        ['motorPulleyTeethInput', 'mainPulleyTeethInput', 'backPulleyMainTeethInput',
         'backPulleyBackTeethInput', 'backMotorPulleyTeethInput', 'backWheelPulleyTeethInput'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('input', updateBeltFromShooterConfig);
            }
        });

        // Bore type change handlers
        function updateBoreMinimum(boreSelectId, teethInputId, labelId) {
            const boreSelect = document.getElementById(boreSelectId);
            const teethInput = document.getElementById(teethInputId);
            const label = document.getElementById(labelId);

            if (!boreSelect || !teethInput) return;

            const minTeeth = getBoreMinTeeth(boreSelect.value);
            teethInput.min = minTeeth;
            if (label) label.textContent = 'min ' + minTeeth + 'T';

            // If using shooter config, re-apply those values directly
            const configSelect = document.getElementById('beltUseShooterConfig');
            if (configSelect && configSelect.value !== 'manual') {
                // Get the correct value from shooter config
                const config = configSelect.value;
                let configValue = null;

                if (teethInputId === 'beltDriveTeeth') {
                    if (config === 'motor-main') {
                        configValue = parseInt(document.getElementById('motorPulleyTeethInput').value);
                    } else if (config === 'main-back') {
                        configValue = parseInt(document.getElementById('backPulleyMainTeethInput').value);
                    } else if (config === 'back-motor-wheel') {
                        configValue = parseInt(document.getElementById('backMotorPulleyTeethInput').value);
                    }
                } else if (teethInputId === 'beltDrivenTeeth') {
                    if (config === 'motor-main') {
                        configValue = parseInt(document.getElementById('mainPulleyTeethInput').value);
                    } else if (config === 'main-back') {
                        configValue = parseInt(document.getElementById('backPulleyBackTeethInput').value);
                    } else if (config === 'back-motor-wheel') {
                        configValue = parseInt(document.getElementById('backWheelPulleyTeethInput').value);
                    }
                }

                if (configValue !== null) {
                    // Set the value from config (it should be valid for the bore type they chose)
                    teethInput.value = configValue;
                }
            } else {
                // Manual mode: just adjust if below minimum
                if (parseInt(teethInput.value) < minTeeth) {
                    teethInput.value = minTeeth;
                }
            }

            // Trigger recalculation
            calculateBelt();
        }

        document.getElementById('beltDriveBore').addEventListener('change', function() {
            updateBoreMinimum('beltDriveBore', 'beltDriveTeeth', 'beltDriveMinLabel');
        });

        document.getElementById('beltDrivenBore').addEventListener('change', function() {
            updateBoreMinimum('beltDrivenBore', 'beltDrivenTeeth', 'beltDrivenMinLabel');
        });

        // Belt calculator - live update function
        function calculateBelt() {
            const mode = document.getElementById('beltCalcMode').value;
            const pitchMM = parseFloat(document.getElementById('beltPitch').value);
            const resultDiv = document.getElementById('beltResult');
            const resultContent = document.getElementById('beltResultContent');

            const commonBelts = pitchMM === 5 ? COMMON_BELT_SIZES_5M : COMMON_BELT_SIZES_3M;

            let html = '';

            if (mode === 'findBelt') {
                const driveTeeth = parseInt(document.getElementById('beltDriveTeeth').value);
                const drivenTeeth = parseInt(document.getElementById('beltDrivenTeeth').value);
                const distanceInches = parseFloat(document.getElementById('beltDistance').value);
                const distanceMM = distanceInches * 25.4;

                const beltLengthMM = calculateBeltLength(driveTeeth, drivenTeeth, distanceMM, pitchMM);
                const beltTeeth = Math.round(beltLengthMM / pitchMM);

                // Find closest standard belt sizes
                const sortedBelts = [...commonBelts].sort((a, b) =>
                    Math.abs(a - beltLengthMM) - Math.abs(b - beltLengthMM)
                );
                const closest = sortedBelts.slice(0, 3);

                html += '<div style="color: #00ff88; font-size: 1.1em; margin-bottom: 8px;">';
                html += 'Calculated Belt: <strong>' + beltLengthMM.toFixed(1) + 'mm</strong> (~' + beltTeeth + ' teeth)';
                html += '</div>';

                html += '<div style="margin-bottom: 8px;">Ratio: ' + (drivenTeeth / driveTeeth).toFixed(3) + ':1</div>';

                html += '<div style="margin-top: 10px;"><strong>Closest Standard Belts:</strong> <small style="color: #888;">(click to find optimal pulleys)</small></div>';
                const currentRatio = drivenTeeth / driveTeeth;
                for (let beltIdx = 0; beltIdx < closest.length; beltIdx++) {
                    const belt = closest[beltIdx];
                    const newDistance = calculateCenterDistance(driveTeeth, drivenTeeth, belt, pitchMM);
                    const diff = belt - beltLengthMM;
                    const distDiff = newDistance ? (newDistance / 25.4 - distanceInches) : 0;
                    const distErrorMM = Math.abs(distDiff * 25.4);
                    const beltId = 'beltOption_' + beltIdx;

                    html += '<div style="margin: 4px 0; padding: 6px; background: rgba(89,0,0,0.2); border-radius: 4px; cursor: pointer; border-left: 3px solid ' + (distErrorMM < 1 ? '#00ff88' : '#590000') + ';" onclick="toggleBeltPulleyOptions(\'' + beltId + '\', ' + belt + ', ' + distanceInches + ', ' + currentRatio.toFixed(6) + ', ' + pitchMM + ')">';
                    html += '<strong>' + belt + 'mm</strong> (' + (belt / pitchMM) + 'T) - ';
                    html += '<span style="color: ' + (diff >= 0 ? '#ffaa00' : '#00ff88') + ';">' + (diff >= 0 ? '+' : '') + diff.toFixed(1) + 'mm</span>';
                    if (newDistance) {
                        html += '<br><small>With current pulleys: ' + (newDistance / 25.4).toFixed(4) + '" (error: ' + (distDiff >= 0 ? '+' : '') + distDiff.toFixed(4) + '")</small>';
                    }
                    html += '<div id="' + beltId + '" style="display: none; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);"></div>';
                    html += '</div>';
                }

            } else if (mode === 'findDistance') {
                const driveTeeth = parseInt(document.getElementById('beltDriveTeeth').value);
                const drivenTeeth = parseInt(document.getElementById('beltDrivenTeeth').value);
                let beltInput = parseFloat(document.getElementById('beltLength').value);

                // Determine if input is teeth or mm
                let beltLengthMM;
                if (beltInput < 100) {
                    // Likely teeth count
                    beltLengthMM = beltInput * pitchMM;
                    html += '<div style="color: #888; font-size: 0.85em; margin-bottom: 8px;">Interpreted as ' + beltInput + ' teeth = ' + beltLengthMM + 'mm</div>';
                } else {
                    beltLengthMM = beltInput;
                }

                const distanceMM = calculateCenterDistance(driveTeeth, drivenTeeth, beltLengthMM, pitchMM);

                if (distanceMM) {
                    const distanceInches = distanceMM / 25.4;
                    html += '<div style="color: #00ff88; font-size: 1.1em; margin-bottom: 8px;">';
                    html += 'Center-to-Center: <strong>' + distanceInches.toFixed(4) + '"</strong> (' + distanceMM.toFixed(2) + 'mm)';
                    html += '</div>';
                    html += '<div>Ratio: ' + (drivenTeeth / driveTeeth).toFixed(3) + ':1</div>';
                    html += '<div>Belt: ' + beltLengthMM + 'mm (' + (beltLengthMM / pitchMM) + 'T)</div>';
                } else {
                    html += '<div style="color: #ff4444;">Belt too short for these pulleys!</div>';
                }

            } else if (mode === 'findPulleys') {
                let beltInput = parseFloat(document.getElementById('beltLength').value);
                const distanceInches = parseFloat(document.getElementById('beltDistance').value);
                const targetRatio = parseFloat(document.getElementById('beltRatio').value);
                const distanceMM = distanceInches * 25.4;
                const use3DPrintable = document.getElementById('belt3DPrintable').checked;

                // Determine if input is teeth or mm
                let beltLengthMM;
                if (beltInput < 100) {
                    beltLengthMM = beltInput * pitchMM;
                } else {
                    beltLengthMM = beltInput;
                }

                const results = findPulleyCombinations(beltLengthMM, distanceMM, targetRatio, pitchMM, 0.1, use3DPrintable);

                if (results.length > 0) {
                    html += '<div style="margin-bottom: 8px;">Belt: ' + beltLengthMM + 'mm | Target Ratio: ' + targetRatio.toFixed(2) + ':1</div>';
                    if (use3DPrintable) {
                        html += '<div style="margin-bottom: 8px; color: #ffaa00; font-size: 0.85em;">🖨️ Including 3D printable pulley sizes</div>';
                    }
                    html += '<div style="margin-bottom: 8px;"><strong>Best Pulley Combinations:</strong></div>';

                    for (const r of results) {
                        const isGoodFit = r.distanceErrorPercent < 2;
                        const isPerfect = r.distanceError < 0.5; // Less than 0.5mm error
                        let bgColor = isGoodFit ? '0,100,0' : '89,0,0';
                        if (isPerfect) bgColor = '0,150,0';

                        html += '<div style="margin: 4px 0; padding: 6px; background: rgba(' + bgColor + ',0.2); border-radius: 4px; border-left: 3px solid ' + (r.is3DPrint ? '#ffaa00' : 'transparent') + ';">';

                        // Show pulley teeth with 3D print indicators
                        const driveLabel = r.isCustomDrive ? '<span style="color: #ffaa00;">' + r.drive + 'T 🖨️</span>' : r.drive + 'T';
                        const drivenLabel = r.isCustomDriven ? '<span style="color: #ffaa00;">' + r.driven + 'T 🖨️</span>' : r.driven + 'T';

                        html += '<strong>' + driveLabel + ' : ' + drivenLabel + '</strong> (ratio: ' + r.ratio.toFixed(3) + ':1)<br>';
                        html += '<small>Distance: ' + (r.calculatedDistance / 25.4).toFixed(4) + '" ';

                        if (isPerfect) {
                            html += '<span style="color: #00ff88;">(error: ' + (r.distanceError / 25.4).toFixed(4) + '" - PERFECT!)</span>';
                        } else {
                            html += '(error: ' + (r.distanceError / 25.4).toFixed(4) + '" / ' + r.distanceErrorPercent.toFixed(1) + '%)';
                        }
                        html += '</small>';

                        if (r.is3DPrint) {
                            html += '<br><small style="color: #ffaa00;">Requires 3D printed pulley</small>';
                        }
                        html += '</div>';
                    }
                } else {
                    html += '<div style="color: #ff4444;">No suitable pulley combinations found. Try adjusting ratio tolerance or belt size.</div>';
                }
            }

            resultContent.innerHTML = html;
            resultDiv.style.display = 'block';
        }

        // Belt calculator - live update on any input change
        ['beltPitch', 'beltCalcMode', 'beltDriveTeeth', 'beltDrivenTeeth', 'beltDistance',
         'beltLength', 'beltRatio', 'belt3DPrintable', 'beltUseShooterConfig',
         'beltDriveBore', 'beltDrivenBore'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('input', calculateBelt);
                el.addEventListener('change', calculateBelt);
            }
        });

        // Keep the button as fallback but also trigger on click
        document.getElementById('calculateBeltBtn').addEventListener('click', calculateBelt);

        // Initialize on page load
        updateConfigDropdown();
        updateOverlaysList();

        // Initial setup
        updateMotorSetupVisibility();
        calculate();
    </script>
</body>
</html>
